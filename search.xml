<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++ 关键字整理</title>
      <link href="/2018/10/05/C++%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/"/>
      <url>/2018/10/05/C++%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h1><p>C++11 引入的新的<strong>类型说明符</strong>. 与具体的 int,double 之类的类型说明符不同，其作用为：让编译器通过<strong>初始值</strong>来推算变量类型。因此 auto 变量必须要有初始值。</p><p>可使用 auto 在一条声明语句中声明多个变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a 为 int 类型变量，b 为 int*变量</span></span><br><span class="line"><span class="keyword">auto</span> a=<span class="number">1</span>, *b=&amp;a;</span><br></pre></td></tr></table></figure></p><p>当以下情况时，auto 推断出的类型与初始值类型并不完全一致：</p><ul><li>初始值为<strong>引用</strong>类型时，将直接使用所引用对象的类型作为 auto 类型。</li><li>auto 一般会忽略<strong>顶层 const</strong>, 保留<strong>底层 const</strong>. 若想让 auto 类型为一个顶层 const, 需使用<code>const auto</code>.</li><li>auto 与 &amp; 引用一起使用，将引用类型设置为 auto.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">auto</span> &amp;b = a;    <span class="comment">//b 为 int 引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;c = <span class="number">20</span>;    <span class="comment">//c 为整形常量引用。可绑定字面值</span></span><br></pre></td></tr></table></figure><h1 id="2-const"><a href="#2-const" class="headerlink" title="2. const"></a>2. const</h1><ul><li>修饰函数</li><li>修饰<strong>指针 / 引用</strong>类型的变量</li><li>常对象成员</li><li><code>mutable</code> 为其反义词</li></ul><h2 id="2-1-修饰函数"><a href="#2-1-修饰函数" class="headerlink" title="2.1. 修饰函数"></a>2.1. 修饰函数</h2><ul><li>修饰成员函数整体<ul><li>释义：修饰成员函数，也就是修饰其中的<code>this</code>指针，使其无法修改类中的数据。</li><li>注意：在常成员函数中，禁止对类属性进行<strong>修改</strong>, 也禁止调用本类的<em>非常成员函数</em>.</li><li>使用：任何不修改类属性的方法，均应该被声明为常成员函数。</li></ul></li><li>修饰函数形参<ul><li>释义：说明本形参在该函数中不可被修改。一般和引用一起使用。（使用引用减少数据拷贝的消耗，又需要防止其被<em>无意修改</em>).</li><li>使用：在该形参不需要被修改时，尽量用 const 修饰。</li></ul></li><li><p>修饰返回的指针或引用</p><ul><li>释义：表示返回值不可被修改。只能把该指针赋给用 const 修饰的指针变量或引用。</li><li>注意：当函数返回的为值时，在接受返回值的过程中，会进行值传递。所以当返回类型为值时，使用 const 修饰无效。</li><li><p>返回引用的情况不多，有以下两个用途</p><ul><li><p>类重载赋值运算符时，方便实现赋值的链式表达。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造，析构，拷贝构造 都省略了</span></span><br><span class="line">    frind <span class="keyword">const</span> ostream&amp; <span class="keyword">operator</span>=(ostream&amp;out, MyClass val) &#123;</span><br><span class="line">        out &lt;&lt; val.m_num;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass a, b, c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br></pre></td></tr></table></figure></li><li><p>用于返回临时变量时，防止外部对该临时变量进行修改。</p></li></ul></li></ul></li></ul><h2 id="2-2-修饰-指针-引用-类型的变量"><a href="#2-2-修饰-指针-引用-类型的变量" class="headerlink" title="2.2. 修饰 指针 引用 类型的变量"></a>2.2. 修饰 指针 引用 类型的变量</h2><ul><li>顶层 const<ul><li>只可用于修饰指针。修饰引用时，无意义。（因为引用本来就不可改变指向的位置)</li><li>格式：<code>类型 *const 变量名</code> eg: <code>int *const num</code></li><li>释义：<strong>常量指针</strong>, const 用于修饰该变量，使其值不可改变。（指针值不变，也就是说指针所指位置不可变)</li><li>特别说明：<strong>常量指针</strong>和<strong>常量引用</strong>.<ul><li>其中常量引用说明的是：<em>可指向常量的引用</em>. 且常量引用为底层 const.</li></ul></li></ul></li><li>底层 const<ul><li><code>const 类型 &amp; 变量名</code> eg: <code>const int &amp;a</code><ul><li>可指向常量的引用。不论是常量还是变量，都无法通过该引用来修改其值。</li><li>常量需要使用引用时，必须使用该语法指定引用。</li><li><code>const 类型 * 变量名</code> eg: <code>const int *a</code>. 可指向常量的指针。（意义同上)</li></ul></li></ul></li></ul><h2 id="2-3-常对象成员"><a href="#2-3-常对象成员" class="headerlink" title="2.3. 常对象成员"></a>2.3. 常对象成员</h2><ul><li>用于修饰类的数据成员</li><li><p>初始化的方法</p><ul><li><p>使用初始化列表。在类的构造函数中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass(): num(<span class="number">10</span>), str(<span class="string">"abc"</span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">const</span> String str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用作静态成员变量（类变量). 因为其是独立进行初始化的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尽量在。cpp 中进行类变量的定义</span></span><br><span class="line"><span class="comment">// 若只是类变量定义，可不进行赋值。但此处还有 const 修饰，必须进行赋值，否则默认赋值。</span></span><br><span class="line"><span class="keyword">int</span> MyClass::num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3-constexpr"><a href="#3-constexpr" class="headerlink" title="3. constexpr"></a>3. constexpr</h1><ul><li>定义：常量表达式（const expression)：值不会改变，且在编译中就得到计算结果的表达式。</li><li><p>定义中有两个关键点：</p><ul><li>值不会改变，也就必须为<code>const</code>类型。</li><li><p>在编译中就要得到计算结果。一个对象 / 表达式是否为常量表达式，由其<strong>数据类型</strong>和<strong>初始值</strong>共同决定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">// 非常量表达式（非 const)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = func();    <span class="comment">// 非常量表达式 （无法在编译中得到计算结果）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b= <span class="number">10</span>;    <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = b+<span class="number">1</span>;    <span class="comment">// 常量表达式</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>constexpr 并不是类型说明符，虽然与类型说明符 const 一样，均可放于类型说明符前面或后面，但一般将其放于前面。</li></ul><h2 id="3-1-constexpr变量"><a href="#3-1-constexpr变量" class="headerlink" title="3.1. constexpr变量"></a>3.1. <code>constexpr</code>变量</h2><p>constexpr 比 const 更为严格。constexpr 变量是必须由常量表达式初始化的 const 变量。</p><p>在复杂系统中，几乎不可能分辨一个初始值到底是不是常量表达式。所以 C++11 规定：可将变量声明为<code>constexpr</code>类型变量，以便由编译器验证变量值是否为一个常量表达式。该变量一定是一个<strong>常量</strong>， 且必须使用常量表达式初始化。</p><p>若某变量是一个常量表达式，则把它声明为<code>constexpr</code>类型</p><h3 id="3-1-1-字面值类型"><a href="#3-1-1-字面值类型" class="headerlink" title="3.1.1. 字面值类型"></a>3.1.1. 字面值类型</h3><p>字面值类型（literal type），声明<code>constexpr</code>变量时可用的类型。因为需在编译时得到计算，说以字面值类型一般比较简单。</p><p>字面值类型包含：</p><ul><li>算数类型</li><li>引用和指针。但初始值被严格限制。指针初始值必须为 nullptr，0，存储于某固定地址中的对象（全局变量，静态局部变量，堆空间中的变量）。</li><li>。</li></ul><h2 id="3-2-constexpr和指针"><a href="#3-2-constexpr和指针" class="headerlink" title="3.2. constexpr和指针"></a>3.2. <code>constexpr</code>和指针</h2><p>作用与顶层 const 类似，修饰的为指针本身。</p><h2 id="3-3-constexpr函数"><a href="#3-3-constexpr函数" class="headerlink" title="3.3. constexpr函数"></a>3.3. <code>constexpr</code>函数</h2><p>能作为<code>constexpr</code>变量的初始值的函数。在给 constexpr 变量初始化时，编译器将函数调用替换为其结果值。且为了能在编译过程中展开，其被隐式指定为<strong>内联函数</strong>。<br>该函数需满足以下条件：</p><ul><li>函数返回类型及所有形参类型都必须为<strong>字面值类型</strong>。</li><li>函数体中必须有且只有一条 return 语句。</li></ul><p>该函数不一定返回常量表达式。<br>通常把 constexpr 函数放于头文件，因为它们允许在程序中被多次定义（每次定义必须相同），且编译器要将函数展开为内联形式，除了需要函数声明，还需要函数的实现。</p><hr><h1 id="4-decltype"><a href="#4-decltype" class="headerlink" title="4. decltype"></a>4. decltype</h1><p>C++11 引入的第二种<strong>类型说明符</strong>. 用于分析并返回操作数的数据类型。</p><ul><li>与<code>auto</code>不同点：<br>只分析表达式，并得到其类型。并不实际进行运算（只进行类型之间的计算)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(a+b) c;    <span class="comment">//c 类型为 a+b 计算结果的类型。但 a+b 并未进行真正计算。</span></span><br></pre></td></tr></table></figure><h1 id="5-default"><a href="#5-default" class="headerlink" title="5. default"></a>5. default</h1><blockquote><p>C++11 特性</p></blockquote><ul><li>背景：C++ 类中有 4 个特殊的成员函数：默认构造，析构，默认拷贝构造，默认 = 重载。若编写时未显式定义，则编译器会生成默认的函数。且编译器生成的要比我们写的 {} 函数体为空的函数要执行效率高。</li><li>问题：以，默认构造函数为例：但当我们编写了自己的构造函数，… 时，默认构造函数就不会生成。为了要调用默认构造函数，必须自己将其写出。eg: A() {} 但这样又累，执行效率也不如编译器自动生成的高。所以 defaulted 函数粉墨登场。</li><li>语法：以默认构造为例：A() =default; 这样写后，编译器就会自动为其生成函数体了。保留了之前的执行效率。</li><li>当与虚函数结合使用时，以析构函数为例：virtual ~A() =default; 这样当子类继承该类时，就可以实现子类析构时的多态。</li><li>defaulted 函数即可在类内定义 (inline) 也可在类外定义 (out-of-line).</li><li>只可用于以上四种特殊的成员函数上。</li><li><p>代码示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       X() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">       X(<span class="keyword">const</span> X&amp;);</span><br><span class="line">       X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span><br><span class="line">       <span class="keyword">virtual</span> ~X() = <span class="keyword">default</span>;  <span class="comment">// 析构函数 + 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line">X::X(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;     <span class="comment">// 拷贝赋值操作符</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="6-delete"><a href="#6-delete" class="headerlink" title="6. delete"></a>6. delete</h1><p>释放 new 所分配的对象。</p><ul><li><p>释放一个变量空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>释放 new 分配的数组，用<code>delete []</code>, 且<code>[]</code>中无需写出长度</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete []<span class="built_in"> array </span>;</span><br></pre></td></tr></table></figure></li></ul><ol><li>背景：因为当我们没有显式的定义赋值构造，拷贝构造函数。.., 当需要时，编译器会自动帮我们生成。（很便利是吧？但也太无脑了。) 当我们不想让对象之间相互拷贝呢？我能就需要阻止编译器的这种行为。</li><li>deleted 函数，用于禁用掉想禁用的函数。（任何函数都行). 禁用某些不期望的转换或操作符。</li><li>语法：eg: A(const A &amp;)=delete;</li><li>只能在函数中定义。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Qt 中，常用于构建 单例 类中。（禁用掉拷贝构造和 = 重载。)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(<span class="keyword">double</span>);                  <span class="comment">// 可以 X a(1)</span></span><br><span class="line">  X(<span class="keyword">int</span>) = <span class="keyword">delete</span>;            <span class="comment">// 不可以 X a(1.2)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;     <span class="comment">// 不能用 new X</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;     <span class="comment">// 不能用 new X[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="7-explicit"><a href="#7-explicit" class="headerlink" title="7. explicit"></a>7. explicit</h1><p>修饰构造函数，作用为：可以禁止”单参数构造函数”被用于自动类型转换中。</p><blockquote><p>详见 类。md 中的”显式构造函数”部分。</p></blockquote><h1 id="8-extern-链接指示"><a href="#8-extern-链接指示" class="headerlink" title="8. extern 链接指示"></a>8. <code>extern</code> 链接指示</h1><ul><li>C++ 使用链接指示 (<em>linkage directive</em>) 指出任意非 C++ 函数所用语言。</li><li>链接指示不能出现在<em>类定义</em>或<em>函数定义</em>内部。且必须<strong>在函数的每个声明中都出现</strong>.</li><li><p><code>extern &quot;C&quot;</code>: 告知编译器在编译这个符号（函数或变量) 时，按照 C 的规则对符号进行处理。(C++ 因为有函数重载等，所以在符号翻译时，会增加很多额外的东西，但 C 翻译时就会简单许多。)</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 复合语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"c_inc.h"</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>编译器在编译 C++ 版本的程序时，会定义<code>__cplusplus</code>变量。所以可以使用该变量进行如下处理：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//includ c 头文件</span></span><br><span class="line"><span class="comment">//---- 代码区 ---</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>指向 extern “C” 的函数指针：如果一个函数指针要指向一个 C 函数，则这个函数指针声明时，也需要使用相同的链接指示。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">// C 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span>)</span></span>;            <span class="comment">//c++ 函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line">pf1 = funcA;    <span class="comment">// 正确</span></span><br><span class="line">pf1 = funcB;    <span class="comment">// 错误。不匹配</span></span><br><span class="line"> </span><br><span class="line">pf2 = funcA;    <span class="comment">// 错误。不匹配</span></span><br><span class="line">pf2 = funcB;    <span class="comment">// 正确。</span></span><br></pre></td></tr></table></figure></li><li><p>链接指示对整个声明都有效。不仅对函数有效，还对类型为<em>函数指针</em> 的<em>返回值</em> 或<em>形参类型</em> 有效。所以如果想让函数与形参和返回值的链接指示不同，可使用<em>类型别名</em>.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f1 是一个 C 函数，形参也是一个 C 函数</span></span><br><span class="line">extern "C" void f1(void(*)(int));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// PF_cfunc 类型为一个指向 C 函数 的函数指针。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PF_cfunc)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(PF_cfunc)</span></span>;    <span class="comment">//f2 为 C++ 函数，参数为一个指向 C 函数的函数指针</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="9-friend"><a href="#9-friend" class="headerlink" title="9. friend"></a>9. friend</h1><ul><li>友元关系只是<strong>单向</strong>的，不可传递与继承。</li><li>友元关系在一定程度上，打破了封装的原则，所以不可滥用！</li><li>友元关系可分为<ul><li>友元函数</li><li>友元类</li></ul></li></ul><h2 id="9-1-友元函数"><a href="#9-1-友元函数" class="headerlink" title="9.1. 友元函数"></a>9.1. 友元函数</h2><ul><li>作用：设置一个非该类成员的函数为该类的友元函数，该函数可访问该类的私有成员。</li><li><p>使用场景：</p><ul><li>综述：无法实现为成员函数，但还需要访问私有成员时。</li><li><p>运算符重载</p><ul><li><p>当第一个参数非本类类型时，无法实现其为本类的成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，析构函数，拷贝构造函数 省略</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 可实现为成员函数，也可实现为 友元函数。此处实现为成员函数</span></span><br><span class="line">    MyClass <span class="keyword">operator</span>+(<span class="keyword">const</span> MyClass a) &#123;</span><br><span class="line">        <span class="keyword">return</span> MyClass(x+a.x, y+a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为第一个参数非本类类型，只可实现为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyClass num);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> MyClass num)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; num.x &lt;&lt; num.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一些特殊情况，为提高执行效率，直接操作私有成员，而非通过其封装好的接口操作。</p></li></ul></li></ul><h2 id="9-2-友元类"><a href="#9-2-友元类" class="headerlink" title="9.2. 友元类"></a>9.2. 友元类</h2><ul><li>作用：使一个类可以访问目标类的任意成员（包括私有成员).</li><li>方法：类 A 要访问类 B 的私有成员，则在类 B 的定义中添加<code>friend class A;</code>.</li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="comment">// 省略 构造函数，析构函数，拷贝构造函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x, m_y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        B b;</span><br><span class="line">        <span class="comment">// 直接访问 B 的私有成员</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.m_x &lt;&lt; b.m_y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="10-inline"><a href="#10-inline" class="headerlink" title="10. inline"></a>10. inline</h1><p>用于：</p><ul><li>内联函数</li><li>成员函数的内联写法</li></ul><h1 id="11-mutable"><a href="#11-mutable" class="headerlink" title="11. mutable"></a>11. mutable</h1><ul><li><code>mutable</code>为<em>可变的，易变的</em> 的含义。与<em>constant</em> (const) 相对。</li><li>用于突破<code>const</code>对于成员函数的限制。<code>const</code>修饰的<strong>成员函数</strong>可修改<code>mutable</code>修饰的<strong>成员变量</strong>.</li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">        count++;    <span class="comment">// 可修改经过 mutable 修饰的成员变量</span></span><br><span class="line">        <span class="comment">// 不可修改其他成员变量，eg: num</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="12-new"><a href="#12-new" class="headerlink" title="12. new"></a>12. new</h1><p>动态分配内存到堆上，可运行时指定储存区大小</p><ul><li><p>分配一个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RN *p = <span class="keyword">new</span> RN(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><p>分配多个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RN *<span class="built_in">array</span> = <span class="keyword">new</span> RN『个数』;</span><br></pre></td></tr></table></figure></li></ul><h1 id="13-operator"><a href="#13-operator" class="headerlink" title="13. operator"></a>13. operator</h1><p>运算符重载</p><ul><li>C++ 将运算符等同于函数看待</li><li>运算符重载的类型<ul><li>左操作数的成员函数：eg: 赋值号<code>=</code>只可被重载为成员函数</li><li>一般函数</li></ul></li></ul><h1 id="14-static"><a href="#14-static" class="headerlink" title="14. static"></a>14. static</h1><ul><li>静态成员变量：（在 Python 中叫做类变量), 为该类所有，而非某一个具体实例。<ul><li>在类内声明。但必须在类外进行初始化。因为在初始化时，才会开辟内存空间 (data 段)（类定义，实例化时都不会给静态成员变量开辟空间). 初始化时可以不赋值，则系统自动赋默认值。（全局为 0, 局部为垃圾值)</li><li>静态成员变量的使用：通过 类名 或 任意实例名 调用。可以在成员函数中使用。</li></ul></li><li>静态成员函数：与普通成员函数相比，无 this 指针。所以只能访问该类中的静态成员变量。</li><li>特别注意：成员函数，或普通函数中使用 static 变量。其作用为扩大了生命周期，但访问范围未改变。<ul><li>因为成员函数其实是不属于每个实例的，所以其中的 static 变量和在普通函数中使用一样，都是<strong>共用</strong>的。</li></ul></li></ul><h2 id="14-1-示例"><a href="#14-1-示例" class="headerlink" title="14.1. 示例"></a>14.1. 示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> myTypeInt a;</span><br><span class="line"><span class="keyword">static</span> myTypeP *b;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myFunc</span><span class="params">()</span></span>;        <span class="comment">// 静态成员函数，只能访问 a 和 *b</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">在 .cpp 中进行初始化静态成员变量，（在此时开辟空间):</span><br><span class="line">myTypeInt a;    <span class="comment">// 可以不赋值</span></span><br><span class="line">myTypeP *b = NUll;</span><br></pre></td></tr></table></figure><blockquote><p>成员函数中使用 static 变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="built_in">std</span>::<span class="built_in">string</span> str) &#123;</span><br><span class="line">        m_str = str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s_num = <span class="number">1</span>;    <span class="comment">// 每个实例都共用该变量。</span></span><br><span class="line">        s_num++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Str: "</span> &lt;&lt; m_str.c_str() &lt;&lt; <span class="string">"  NUM: "</span> &lt;&lt; s_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_str;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">T1</span><span class="params">(<span class="string">"T1"</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">T2</span><span class="params">(<span class="string">"T2"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    T1.Func();    <span class="comment">// "Str: T1  NUM: 2"</span></span><br><span class="line">    T1.Func();    <span class="comment">// "Str: T1  NUM: 3"</span></span><br><span class="line">    T2.Func();    <span class="comment">// "Str: T2  NUM: 4"</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="15-template"><a href="#15-template" class="headerlink" title="15. template"></a>15. template</h1><ul><li>模板是 C++ 支持参数化多态的工具。为了能够编写与类型无关的代码。可分为以下两种：<ul><li>函数模板：针对仅函数参数不同的函数</li><li>类模板：针对仅数据成员和成员函数类型不同的类</li></ul></li><li>模板函数要定义在头文件中。因为在使用模板时，需要对模板参数进行确定。从而生成一个函数或是一个类。所以就需要模板的具体实现对于模板的使用者可见。所以需写到头文件中，在使用时包含。（也可以将实现写到使用的地方，但一般不这样做).</li><li>模板的声明或定义：只能在全局，命名空间，类范围 内。不能在局部范围，函数内进行。</li><li>语法<blockquote><p>T 为模板参数。在具体使用中，T 会被替换为不同的表达式 / 字符串。</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模板的形参：<ul><li>类型模板形参</li><li>非类型模板形参 （只可以为 int, *, &amp;. 而 double 之类的不行)</li><li>模板模板形参（以模板作为参数)</li></ul></li><li><p>默认形参：</p><ul><li><p>类型形参：可以为类模板的类型形参提供默认值，但不可对函数模板的类型形参提供。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>=<span class="title">int</span>&gt;<span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="function">T1 <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;    // 函数定义时不用写 <span class="title">T2</span> 的默认值（写上会有警告)</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">A</span>&lt;T1, T2&gt;:</span>:func() &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>非类型形参：可为类模板，函数模板的非类型形参提供默认值</p></li></ul></li><li><p>类型形参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Y</span>&gt;.....（函数或类)   使用时：&lt;int, float&gt;....</span></span><br></pre></td></tr></table></figure></li><li><p>非类型形参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可指定大小的栈：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">STACKSIZE</span>&gt;<span class="title">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T <span class="built_in">stack</span>[STACKSIZE];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用时：</span></span><br><span class="line">MyStack&lt;<span class="keyword">float</span>, <span class="number">100</span>&gt; a;     <span class="comment">//  a 为 float 类型，元素个数为 100 的栈</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="15-1-函数模板"><a href="#15-1-函数模板" class="headerlink" title="15.1. 函数模板"></a>15.1. 函数模板</h2><ul><li><p>格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名 1， <span class="title">class</span> 形参名 2...&gt; 返回类型 函数名（参数列表) &#123;</span>函数体&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>template 和 class 为关键字。这里的 class 可使用 typename 代替。<br><code>&lt;&gt;</code>中的为模板形参。不能为空。一旦声明了模板形参，就可在函数内部使用该类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 此时，会因为 1 和 2 中 T 类型的不同，而生成两个不同的 add 函数。</span></span><br><span class="line"><span class="number">1.</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="number">2.</span> add(<span class="number">1.3</span>, <span class="number">2.4</span>);</span><br><span class="line"><span class="number">3.</span> <span class="keyword">int</span> a= <span class="number">1</span>, b = <span class="number">2</span>;  add(a, b);</span><br></pre></td></tr></table></figure><h2 id="15-2-模板类"><a href="#15-2-模板类" class="headerlink" title="15.2. 模板类"></a>15.2. 模板类</h2><ul><li><p>在类的定义 / 该类的成员函数 前都需加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, ...&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>模板类的类名变为了：eg: <code>RN</code><br>要将之前使用类名的地方都替换为新类名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;    // 要加模板声明</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RN</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        RN(T _x = <span class="number">1</span>, T y = <span class="number">1</span>);</span><br><span class="line">        <span class="function">T <span class="title">func</span><span class="params">(T arg)</span></span>; <span class="comment">// 参数，返回值均为 T 类型</span></span><br><span class="line">        <span class="comment">// 参数，返回值均为该类 （但现在该类类名变为 RN&lt;T&gt;)</span></span><br><span class="line">        RN&lt;T&gt;&amp; operate=(RN&lt;T&gt; &amp;arg);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        T x, y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;     // 要加模板声明</span></span><br><span class="line"><span class="class"><span class="title">RN</span>&lt;T&gt;:</span>:RN(T _x, T _y)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;    // 要加模板声明</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">RN</span>&lt;T&gt;:</span>:func(T arg)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//.........</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;    // 要加模板声明</span></span><br><span class="line"><span class="class"><span class="title">RN</span>&lt;T&gt;&amp; <span class="title">RN</span>&lt;T&gt;:</span>:operate=(RN&lt;T&gt; &amp;rag)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义该类的对象时：</span></span><br><span class="line"> RN&lt;<span class="keyword">int</span>&gt; a;    <span class="comment">// 此时该对象对应的类 RN 中所有 T 都被 int 替代。</span></span><br><span class="line"><span class="comment">// 对于模板形参为多个的：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>, <span class="title">class</span> <span class="title">B</span>&gt; <span class="title">class</span> <span class="title">My_RN</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">// 其定义对象时：My_RN &lt;int, float&gt; a;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="16-using"><a href="#16-using" class="headerlink" title="16. using"></a>16. using</h1><p>可用于以下情况：</p><ul><li>声明使用的命名空间</li><li>定义类型别名</li></ul><h2 id="16-1-声明使用的命名空间"><a href="#16-1-声明使用的命名空间" class="headerlink" title="16.1. 声明使用的命名空间"></a>16.1. 声明使用的命名空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;   <span class="comment">// 使用 cin 就不需加 std:: 了</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   <span class="comment">// 使用 std 命名空间</span></span><br></pre></td></tr></table></figure><ul><li>注意：头文件不应包含 using 声明 （防止引用该头文件的程序出现名字冲突)</li></ul><h2 id="16-2-定义类型别名"><a href="#16-2-定义类型别名" class="headerlink" title="16.2. 定义类型别名"></a>16.2. 定义类型别名</h2><p>C++11 规定了可使用 using 定义类型别名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyInt = <span class="keyword">int</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> MyInt;</span><br></pre></td></tr></table></figure></p><h1 id="17-virtual"><a href="#17-virtual" class="headerlink" title="17. virtual"></a>17. virtual</h1><p>虚函数</p><ul><li>纯虚函数：在虚函数声明加<code>=0</code></li></ul><h1 id="18-volatile"><a href="#18-volatile" class="headerlink" title="18. volatile"></a>18. volatile</h1><ul><li>表明本变量 / 类会被意想不到的地方改变。所以每次读取其时，都需要重新载入，而不是读取某寄存器中的存储值。</li><li>用于有多个执行序列的程序都要访问的变量上：<ul><li>多线程程序</li><li>中断中</li><li>并行设备的硬件寄存器</li></ul></li><li>问题：<ul><li>一个参数即可为 const, 又可能为 volatile 修饰。(eg: 只读的状态寄存器) const 表明只读属性。volatile 表明会被不确定因素修改。</li><li>一个指针也可为 volatile 修饰。在其他执行序列中修改了一个指针的指向时。（也就是该指针的值).</li></ul></li></ul><h1 id="19-enum-枚举类型"><a href="#19-enum-枚举类型" class="headerlink" title="19. enum 枚举类型"></a>19. enum 枚举类型</h1><ul><li>虽然枚举定义了唯一的类型，但实际 enum 是由某种整数类型表示的（成员大小).</li><li>c++11 标准中可以指定表示 enum 的类型。如果类型不够容纳所有枚举值，则会引发程序错误。</li><li>不指定类型时，默认情况是 int. 且编译器保证类型足够大，能容纳所有枚举值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type : <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> &#123;</span><br><span class="line">    TypeIs_A = <span class="number">1</span></span><br><span class="line">    , TypeIs_B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-1-枚举类型前置声明"><a href="#19-1-枚举类型前置声明" class="headerlink" title="19.1. 枚举类型前置声明"></a>19.1. 枚举类型前置声明</h2><ul><li>C++11 可提前声明 enum.</li><li>不限制作用域的 enum 需要制定成员大小。</li><li>限定作用域的 enum 可以不指定成员大小，隐式为 int.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type : <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;    <span class="comment">// 必须指定成员大小</span></span><br><span class="line"><span class="keyword">enum</span> MyClass::Type; <span class="comment">// 限定作用域。可以不指定成员大小，默认为 int.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UML 类图</title>
      <link href="/2018/10/05/UML%20%E7%B1%BB%E5%9B%BE/"/>
      <url>/2018/10/05/UML%20%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-推荐网站"><a href="#1-推荐网站" class="headerlink" title="1. 推荐网站"></a>1. 推荐网站</h1><ul><li>UML 类图官方网站：<a href="http://www.uml.org.cn/oobject/201104212.asp" target="_blank" rel="noopener">http://www.uml.org.cn/oobject/201104212.asp</a></li><li>UML 类图中关系的总结：<a href="http://blog.csdn.net/dragonpeng2008/article/details/6836448" target="_blank" rel="noopener">http://blog.csdn.net/dragonpeng2008/article/details/6836448</a></li><li>开源的 UML 工具：<a href="http://www.iteye.com/news/11216-12-best-opensource-uml-tool" target="_blank" rel="noopener">http://www.iteye.com/news/11216-12-best-opensource-uml-tool</a></li><li>在线绘制 UML 类图：<a href="https://www.processon.com" target="_blank" rel="noopener">https://www.processon.com</a></li><li>类间关系：<a href="http://www.cnblogs.com/floodpeak/archive/2008/02/27/1083533.html" target="_blank" rel="noopener">http://www.cnblogs.com/floodpeak/archive/2008/02/27/1083533.html</a></li></ul><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h1><blockquote><p>UML 类图是用于显示<strong>类</strong>, <strong>接口</strong>及它们之间的<strong>静态结构和关系</strong>的一种静态模型<br>速记：”泛，实，组，聚，关，依”. 泛化父类，实现接口，组合（生命期同), 聚合（生命期可不同), 关联，依赖（临时调用)<br>表示方法：泛化（实线空三角箭头), 实现（虚线空三角箭头), 组合（实菱形实线箭头), 聚合（空菱形实线箭头), 关联（实线箭头), 依赖（虚线箭头)</p></blockquote><p><img src="/res/mdImg/UMLguanxi.png" alt="UML"></p><h1 id="3-基本元素"><a href="#3-基本元素" class="headerlink" title="3. 基本元素"></a>3. 基本元素</h1><h2 id="3-1-类"><a href="#3-1-类" class="headerlink" title="3.1. 类"></a>3.1. 类</h2><ul><li>首行为<strong>类名</strong>. 类名为<em>斜体</em>表示该类为<strong>抽象类</strong>.</li><li>第二行为类的<strong>特性</strong>, 也就是<strong>字段</strong>或<strong>属性</strong>. 在之后添加<code>: 该属性的类型名</code>. eg: <code>name :string</code></li><li>第三行为类的<strong>操作</strong>, 也就是<strong>方法</strong>或<strong>行为</strong>. 在之后添加<code>: 返回值类型</code>. eg: <code>func(name :string, age :int) :bool</code></li><li><strong>特性</strong>和<strong>操作</strong>的访问限定符：<code>+</code>表示<code>public</code>; <code>-</code>表示<code>private</code>; <code>#</code>表示<code>protected</code></li></ul><p><img src="/res/mdImg/lei.jpg" alt="类"></p><h3 id="3-1-1-内部类"><a href="#3-1-1-内部类" class="headerlink" title="3.1.1. 内部类"></a>3.1.1. 内部类</h3><ul><li><code>Memento</code>为<code>DataConverter</code>的内部类<br><img src="/res/mdImg/neibulei.jpg" alt="内部类"></li></ul><h2 id="3-2-接口"><a href="#3-2-接口" class="headerlink" title="3.2. 接口"></a>3.2. 接口</h2><ul><li>首行为 &lt;<interface>&gt;和接口名称</interface></li><li>第二行为接口方法</li><li>如附件图所示</li></ul><p><img src="/res/mdImg/jiekou.jpg" alt="接口"></p><h1 id="4-类之间的关系"><a href="#4-类之间的关系" class="headerlink" title="4. 类之间的关系"></a>4. 类之间的关系</h1><p>类之间的关系只是在某个问题域内讨论才有效。</p><ul><li>纵向关系<ul><li>继承</li></ul></li><li>横向关系<ul><li>组合</li><li>聚合</li><li>关联</li><li>依赖</li></ul></li><li>关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</li></ul><h2 id="4-1-泛化-Generalization"><a href="#4-1-泛化-Generalization" class="headerlink" title="4.1. 泛化 (Generalization)"></a>4.1. 泛化 (Generalization)</h2><ul><li>也就是<strong>继承</strong>, <code>is-a</code>的关系，表示<em>一般</em>与<em>特殊</em>之间的关系。</li><li>表示：带三角箭头的实线，箭头指向父类</li><li>示例：如附件图所示。<code>Tiger</code>子类指向<code>Animal</code>父类</li></ul><p><img src="/res/mdImg/fanhua.png" alt="泛化"></p><h2 id="4-2-实现-Realization"><a href="#4-2-实现-Realization" class="headerlink" title="4.2. 实现 (Realization)"></a>4.2. 实现 (Realization)</h2><ul><li>表示<strong>实现接口</strong>， 接口的实现指向接口</li><li>表示：<ul><li>方法 1: 带三角箭头的虚线。实现类指向接口</li><li>方法 2: 棒棒糖表示法，圆圈部分为接口名称。</li></ul></li></ul><p><img src="/res/mdImg/shixian1.jpg" alt="实现 1"><br><img src="/res/mdImg/shixian2.jpg" alt="实现 2"></p><h2 id="4-3-关联"><a href="#4-3-关联" class="headerlink" title="4.3. 关联"></a>4.3. 关联</h2><p>用于表示对象之间的引用关系，常在<strong>类属性</strong>中出现。</p><ul><li><p>分类</p><ul><li>一般关联</li><li>聚合</li><li>组合</li></ul></li><li><p>多重性</p><ul><li>用于表示实例之间的引用个数的关系。</li><li>符号表：</li></ul></li></ul><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">不超过一个</td></tr><tr><td style="text-align:center">0..1</td><td style="text-align:center">0 或 1 个</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">许多</td></tr><tr><td style="text-align:center">0..*</td><td style="text-align:center">0 或许多</td></tr><tr><td style="text-align:center">1..*</td><td style="text-align:center">1 或许多</td></tr></tbody></table><h3 id="4-3-1-组合-Composition"><a href="#4-3-1-组合-Composition" class="headerlink" title="4.3.1. 组合 (Composition)"></a>4.3.1. 组合 (Composition)</h3><ul><li>也称为<strong>合成</strong>.</li><li>一种<code>contains-a</code>的关系，也用来描述<strong>整体</strong>和<strong>部分</strong>的关系。</li><li>与聚合不同，其为强的关联关系。<strong>部分</strong>离开<strong>整体</strong>不可存在。两者<strong>生命周期一致</strong>.</li><li>表示：实心菱形指向整体，箭头可有可无。</li><li>示例：部门为公司的一部分，实心菱形由部门指向公司。<br><img src="/res/mdImg/zhuhe.png" alt="组合"></li></ul><h3 id="4-3-2-聚合-Aggregation"><a href="#4-3-2-聚合-Aggregation" class="headerlink" title="4.3.2. 聚合 (Aggregation)"></a>4.3.2. 聚合 (Aggregation)</h3><ul><li>一种<code>owns a</code>的关系。用来描述<strong>整体</strong>与<strong>部分</strong>关系，且部分可离开整体<strong>单独存在</strong>.</li><li>表示：空心菱形指向整体，箭头可有可无。</li><li>示例：一个汽车有一个引擎和四个轮胎<br><img src="/res/mdImg/juhe.png" alt="聚合"></li></ul><h3 id="4-3-3-一般关联-Association"><a href="#4-3-3-一般关联-Association" class="headerlink" title="4.3.3. 一般关联 (Association)"></a>4.3.3. 一般关联 (Association)</h3><ul><li>一种<code>has a</code>的关系。</li><li>表示：带普通箭头的实线，指向被拥有者。</li><li>可自身关联</li></ul><p><img src="/res/mdImg/guanlian1.jpg" alt="关联 1"><br><img src="/res/mdImg/guanlian2.jpg" alt="关联 2"><br><img src="/res/mdImg/guanlian3.png" alt="关联 3"></p><h2 id="4-4-依赖-Dependency"><a href="#4-4-依赖-Dependency" class="headerlink" title="4.4. 依赖 (Dependency)"></a>4.4. 依赖 (Dependency)</h2><ul><li>最弱的，临时性的关联。</li><li>一种<code>used a</code>关系。一个类的实现需要另一个类的协助。尽量避免双向依赖。</li><li>由<strong>局部变量</strong>, <strong>函数参数</strong>, <strong>静态方法</strong> 对于其他对象的<strong>调用</strong>关系。</li><li>表示：使用类 —&gt; 被依赖（被使用) 者</li><li>一旦被依赖的改变，则使用类必须改变。若使用类改变，和被依赖的无关。</li><li>示例：<br><code>Order</code>类依赖<code>DBUtil</code>类的<code>execute()</code>方法去做一些事情，一旦<code>DBUtil</code>改变，则<code>Order</code>必须改变。</li></ul><p><img src="/res/mdImg/yilai.png" alt="依赖"></p><!-- RES --><!-- RES -->]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 函数相关</title>
      <link href="/2018/10/05/Python%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/10/05/Python%20%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python3</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"func1"</span>)</span><br><span class="line"> </span><br><span class="line">func1()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># ----------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">""" 交换 a 和 b</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line"> </span><br><span class="line">a, b = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">a, b = func2(a, b)</span><br><span class="line">print(a, b)   <span class="comment"># 20, 10</span></span><br></pre></td></tr></table></figure><h1 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h1><ul><li>Python 中对象分为：可修改对象 和 不可修改对象。</li><li>这两类型的对象作为参数传递时：<ul><li>不可修改对象：类似于 C++ 的值传递。将对象拷贝了一份传递过去了。</li><li>可修改对象：类似于 C++ 的引用传递。在函数体内修改对象，函数体外的该函数也会受到影响。</li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(lst)</span>:</span></span><br><span class="line">    lst.append(<span class="string">'end'</span>)</span><br><span class="line"> </span><br><span class="line">myLst = [<span class="string">'hello'</span>, <span class="string">'world'</span>]</span><br><span class="line"> </span><br><span class="line">print( myLst )  <span class="comment"># ['hello', 'world']</span></span><br><span class="line">func(myLst)     <span class="comment"># 传递的为可变数据类型，相当于 C++ 传引用</span></span><br><span class="line">print( myLst )  <span class="comment"># ['hello', 'world', 'end']</span></span><br></pre></td></tr></table></figure><h1 id="3-默认参数"><a href="#3-默认参数" class="headerlink" title="3. 默认参数"></a>3. 默认参数</h1><ul><li>默认参数要放在最后。</li><li>设计默认参数：当函数有多个参数时，将变化大的参数放前，变化小的参数放后，这些变化小的参数就能为默认参数。</li><li>注意：默认参数必须指向<strong>不变对象</strong>. 因为函数在定义时，默认参数的值就被计算出来了。如果默认参数是一个列表，则每次调用的都是同一个列表。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(a, b, str = <span class="string">'hehe'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"func3"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用关键字参数指定各参数值，可不按形参顺序</span></span><br><span class="line">func3(str=<span class="string">'hello'</span>, a=<span class="number">10</span>, b=<span class="number">20</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># --------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(lst=[])</span>:</span></span><br><span class="line">    lst.append(<span class="string">'end'</span>)</span><br><span class="line">    print(lst)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 默认参数必须为不可变数据类型，否则会一直改变这个默认参数对象</span></span><br><span class="line">func()  <span class="comment"># ['end']</span></span><br><span class="line">func()  <span class="comment"># ['end', 'end']</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4. 可变参数"></a>4. 可变参数</h1><ul><li>传入的参数个数是可变的，可为 0 个，1 个，…</li><li><p>对函数形参作处理：加了<code>*</code>的参数，表示会以 list, tuple 的形式导入，存放所有未命名的变量参数。</p></li><li><p>调用时：在 list, tuple 前加一个<code>*</code>, 将其作为可变参数传入。</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">(a, b, *t)</span>:</span></span><br><span class="line">    print(a, b, t)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">        print(x, <span class="string">" "</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 30, 40, 50 将作为元组存入 t 中。</span></span><br><span class="line">func4(<span class="number">10</span> ,<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"> </span><br><span class="line">tempLst = [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">func4(<span class="number">10</span>, <span class="number">20</span>, *tempLst)    <span class="comment"># 使用 list</span></span><br></pre></td></tr></table></figure><h1 id="5-关键字参数"><a href="#5-关键字参数" class="headerlink" title="5. 关键字参数"></a>5. 关键字参数</h1><ul><li>允许传入 0 个或任意个含有参数名的参数，这些关键字参数在函数内部自动组装为一个 dict.<ul><li>若函数形参中包含该参数名，则直接给这个参数赋值。（使得形参赋值的方式更直观，且可以打破形参本身的顺序)</li><li>若不包含，则这些关键字参数在函数内部自动组装为一个 dict, 赋值给用<code>**</code>修饰的形参。（若没有<code>**</code>修饰的形参，则报错)</li></ul></li><li>作用：扩展函数功能。可以在函数中检查有没有传入某个特定的参数，从而执行一些特殊操作。</li><li>使用<strong>命名关键字参数语法</strong>, 可以限制关键字参数的名字。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python3</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, **d)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'d ='</span>, d)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># a 和 b 为必须参数，可改变顺序。这两个参数传入时，直接会赋值给对应形参。</span></span><br><span class="line"><span class="comment"># str1 将被放入一个 dict, 并赋值给 d</span></span><br><span class="line">func(b=<span class="number">10</span>, a=<span class="number">20</span>, str1=<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">func(<span class="number">10</span>, <span class="number">20</span>, str1=<span class="number">1</span>, str2=<span class="number">2</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 也可以使用现有的 dict 给 d 赋值。只是该 dict key 必须为字符串 （因为要作为参数名)</span></span><br><span class="line"><span class="comment"># 注意：d 的参数传递为值传递。不会影响到外部的 dic1</span></span><br><span class="line">dic1 = &#123;<span class="string">'str1'</span>:<span class="number">1</span>, <span class="string">'str2'</span>:<span class="number">2</span>&#125;</span><br><span class="line">func(<span class="number">10</span>, <span class="number">20</span>, **dic1)   </span><br><span class="line"> </span><br><span class="line"><span class="comment">##### 命名关键字语法</span></span><br><span class="line"><span class="comment"># 表示在 *  之后的 name, city 为命名关键字参数，必须使用关键字参数的形式传入。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(a, b, *, name, city)</span>:</span></span><br><span class="line">    print(a, b, name, city)</span><br><span class="line"> </span><br><span class="line">func2(<span class="number">10</span>, <span class="number">20</span>, name=<span class="string">'MyName'</span>, city=<span class="string">'beijing'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当然，命名关键字参数也可以有默认参数。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(a, b, *lst, name=<span class="string">'a'</span>, city)</span>:</span></span><br><span class="line">    print(a, b, lst, name, city)</span><br><span class="line"> </span><br><span class="line">func3(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, city=<span class="string">'citys'</span>) <span class="comment"># 10 20 (30, 40) a citys</span></span><br></pre></td></tr></table></figure><h1 id="6-lambda-表达式"><a href="#6-lambda-表达式" class="headerlink" title="6. lambda 表达式"></a>6. lambda 表达式</h1><blockquote><p>??? 感觉 python 中的 lambda 没有 c++ 中的强大 ???</p></blockquote><ul><li>lambda 拥有自己的命名空间，不能访问<em>自己参数列表之外</em> 或 <em>全局命名空间</em> 里的参数。</li><li>lambda 只包含一句语句，不等同于 C++ 内联函数。它不是为了增加内存效率。</li><li>语法：<code>lambda [arg1 [,arg2,.....argn]]:expression</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python3</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"> </span><br><span class="line">func = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line">a = func(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">print(a)    <span class="comment"># 30</span></span><br></pre></td></tr></table></figure><h1 id="7-任意函数，都可通过-func-args-kw-的形式调用"><a href="#7-任意函数，都可通过-func-args-kw-的形式调用" class="headerlink" title="7. 任意函数，都可通过 func(*args, **kw) 的形式调用"></a>7. 任意函数，都可通过 func(*args, **kw) 的形式调用</h1><blockquote><p>以下是验证用到的一些实例</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证任意函数，都能通过 func(*args, **kw) 的形式调用。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_funcA</span><span class="params">()</span>:</span></span><br><span class="line">    args = (<span class="number">10</span>, <span class="number">20</span>, <span class="string">'hello'</span>)</span><br><span class="line">    funcA(*args)    <span class="comment"># 10 20 hello</span></span><br><span class="line"> </span><br><span class="line">    kw = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">20</span>, <span class="string">'c'</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">    funcA(**kw)     <span class="comment"># 10 20 hello</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># -----</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcB</span><span class="params">(a, b, *l)</span>:</span></span><br><span class="line">    print(a, b, l)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_funcB</span><span class="params">()</span>:</span></span><br><span class="line">    args = (<span class="number">10</span>, <span class="number">20</span>, <span class="string">'hello'</span>)</span><br><span class="line">    funcB(*args)    <span class="comment"># 10 20 ('hello',)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># -----</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcC</span><span class="params">(a, *l, **d)</span>:</span></span><br><span class="line">    print(a, l, d)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_funcC</span><span class="params">()</span>:</span></span><br><span class="line">    args = (<span class="number">10</span>, <span class="number">20</span>, <span class="string">'hello'</span>)</span><br><span class="line">    kw = &#123;<span class="string">'key1'</span>: <span class="number">1</span>, <span class="string">'key2'</span>: <span class="number">2</span>&#125;</span><br><span class="line">    funcC(*args, **kw)  <span class="comment"># 10 (20, 'hello') &#123;'key1': 1, 'key2': 2&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># -----</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcD</span><span class="params">(a, *, b, c)</span>:</span></span><br><span class="line">    print(<span class="string">'a:'</span>, a, <span class="string">'b:'</span>, b, <span class="string">'c:'</span>, c)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_funcD</span><span class="params">()</span>:</span></span><br><span class="line">    args = (<span class="number">10</span>, )</span><br><span class="line">    kw = &#123;<span class="string">'b'</span>:<span class="number">1</span>, <span class="string">'c'</span>:<span class="number">2</span>&#125;</span><br><span class="line">    funcD(*args, **kw)  <span class="comment"># a: 10 b: 1 c: 2</span></span><br><span class="line"> </span><br><span class="line">call_funcA()</span><br><span class="line">call_funcB()</span><br><span class="line">call_funcC()</span><br><span class="line">call_funcD()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
