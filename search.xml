<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>搭建属于自己的知识管理系统</title>
      <link href="/2018/10/07/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/10/07/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>友情提示: 你可以选择以下镜像网站进行阅读:</p><ul><li><a href="https://zhaoyongcnsx.github.io" target="_blank" rel="noopener">GitHub Pages</a></li><li><a href="http://47.92.146.3" target="_blank" rel="noopener">国内个人站</a></li></ul></blockquote><!-- URL --><!-- /URL --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>众所周知, 搭建自己的知识管理系统是十分重要的. </p><p>笔者对知识管理系统的需求有以下几点:</p><ul><li>支持多平台. PC, 移动端都得有. 移动端编辑功能可以弱一点, 但是查找功能不能弱. 毕竟移动端最大的使用场景就是随时随地找找笔记.</li><li>支持扩展. 除非功能十分强大, 不然就要对扩展有良好的支持. 总不能软件自身 Markdown 渲染的那么丑, 还不让人自定义吧.</li><li>数据安全性. 这倒不是说笔记有啥机密, 主要都是自己写的东西, 莫名奇妙的丢了也挺心疼的. </li><li>平台可替代性. 如果这家公司倒闭了呢, 总得让我能很方便的把数据导出去吧, 最好能直接把 Markdown 导出, 这样导入到其他软件也很方便. </li></ul><p>以下是对一些软件使用后的吐槽…</p><ul><li>为知笔记: 笔者是一个购买了多年为知笔记的用户, 其各平台客户端功能完成度都不错. 虽然 Markdown 编辑器烂成渣, 不过可以在笔记中添加使用第三方编辑器. 这一点还是值得给点赞的. 而为知最大的不足就是搜索. Markdown 笔记内容搜索体验很差. 而且近年感觉为知的更新速度放缓了, 论坛也很少有回复了, 有种渐行渐远的感觉… </li><li>有道云笔记: 搜索渣的连为知都不如, 虽然体量很大, 但体验确实做得不好.</li><li>Leanote: 刚开始接触 Leanote 时, 有种被惊艳到的感觉. 优良的 Markdown 编辑体验, 自带 blog 展示. 还是开源软件, 不仅客户端开源, 服务器端也开源了. 笔者于是很快搭建了自己的 Leanote 服务. 可等到新鲜劲过去之后, 问题也暴露的越来越多. 它的 安卓 和 ios 客户端功能完成度很低. 而且查了下 gitHub, 都有一年以上没更新了… 再加上自建服务器稳定性有待商榷, 所以还是弃坑了. </li><li>VNote: 本地功能很强大, 但是好像目前还没有做同步 和 移动端软件.</li><li>…</li></ul><h1 id="2-方案设计"><a href="#2-方案设计" class="headerlink" title="2. 方案设计"></a>2. 方案设计</h1><p>现有的笔记类软件很难满足要求. 在一个个软件的使用和比较中, 总在做着艰难的取舍. 就没有一个符合自己全部要求的方案吗? 有, 那就是自己搞一个! </p><p>历史总是惊人的相似, 轮子总是重复的创造…</p><p>如果从 PC 到 移动端 再到 服务器 完整打造一套软件系统, 所花费的时间成本太大了. 而比较现实的方案是: 先应用一些现有的软件, 辅以扩展性良好的通用数据结构, 打造能基本满足需求的系统. 等之后再从短板开始进行逐一替换.</p><p>那就先说说这个现有的实现方案吧. 使用体验上虽然还不完美, 但也绝对比之前的体验要好. </p><ul><li>使用 Markdown 作为笔记格式, 使用单纯的目录结构来管理笔记.</li><li>使用 git 负责笔记同步, 国内可选择同步到 <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 等平台. 可以设置 git 项目属性为 private. </li><li>使用 Hexo 生成博客, 托管到 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> 上. </li><li>Win, Mac 下, 可使用<code>VS Code</code>加载笔记文件夹, 且可以通过安装插件, 完成 Markdown 图片粘贴, git 快速同步, Markdown 高级预览.</li><li>ios 下, 有很多支持 git 的软件, 试用了一圈发现还是<code>Working Copy</code>更符合我的使用习惯. 主要是因为其支持 查找文档内容 和 Markdown 预览. 虽然 Markdown 预览有些瑕疵, 但是不影响使用.</li><li>运行在自己服务器中的一些脚本, 用于自动更新 Hexo 生成 blogs.</li></ul><h1 id="3-效果体现"><a href="#3-效果体现" class="headerlink" title="3. 效果体现"></a>3. 效果体现</h1><p>忙活了好几天, 终于完成了. 最后达到的效果是: </p><ul><li>在任一客户端更改笔记后, 将笔记 push 到码云. </li><li>这会触发一个预先在码云该项目中设置了的 web hook, 它会发送一个 POST 请求到笔者的服务器. </li><li>在该服务器上运行着一个 Node.js 服务. 当收到请求时, 会执行:<ol><li>pull 笔记到本地, 读取文档中的一个配置文件. 该文件说明了 blogs 的生成规则, 包括哪些笔记要生成 blogs, 用到哪些 tags, 是否接受评论, …</li><li>将这些待发布为 blog 的笔记做一些特殊处理后, 生成 md 文件到 Hexo source 目录下. </li><li>复制这些 md 文件中用到的图片到 Hexo source 目录下.</li><li>调用 Hexo 生成 Html 文件. 再 push 到 GitHub Pages 中.</li><li>自动发送邮件给笔者, 通知执行结果, 并把日志文件以附件形式包含在邮件中.</li></ol></li></ul><h1 id="4-实现过程中的问题记录"><a href="#4-实现过程中的问题记录" class="headerlink" title="4. 实现过程中的问题记录"></a>4. 实现过程中的问题记录</h1><p>在整个过程中, 遇到了一些问题, 积累点滴, 以供成长.</p><h2 id="4-1-在-Markdown-中插入图片和附件"><a href="#4-1-在-Markdown-中插入图片和附件" class="headerlink" title="4.1. 在 Markdown 中插入图片和附件"></a>4.1. 在 Markdown 中插入图片和附件</h2><p>在 Markdown 文档中插入图片, 一直是一个痛点. 而现有软件的解决思路一般有以下几种:</p><ul><li>插入图片时, 将图片传到自己服务器, 并返回一个 URL. 和使用<strong>网络图床</strong>的解决方法一致.</li><li>插入图片时, 将图片复制到一个指定路径, 并返回该路径. 同步时, 将图片和文档一起同步. </li></ul><p>方案一中管理图片时, 需要先登录到图床, 再进行修改. 万一哪天图床挂了, 图床之间的迁移成本太高了. 所以笔者采用了方案二. 具体做法是: 在笔记的同级目录, 创建文件夹 res, 将图片拷贝到该文件夹下. 在 note1.md 中使用 <code>![图片标题](./Res/img1.png)</code> 的方式来引用该图片. 目录结构示意图如下:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res</span><br><span class="line"> <span class="string">|-- img1.png</span></span><br><span class="line"></span><br><span class="line">note1.md</span><br></pre></td></tr></table></figure><p>VS Code 可使用 <code>Paste Image</code> 插件将剪切板的图像生成图片文件, 存储到特定目录下, 再将路径插入到文档中. 可使用 <code>Markdown Preview Enhanced</code> 来选择现有的图片插入. 该插件会将图片复制到指定目录, 并在文档中增加内容. 只需要在安装完插件后, 增加配置如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//----------------- markdown preview Enhanced -------------------</span><br><span class="line">// 使用图片助手插入本地图片时, 图片复制到的路径</span><br><span class="line">"markdown-preview-enhanced.imageFolderPath": "./res/",</span><br><span class="line"></span><br><span class="line">//----------------- paset image -------------------</span><br><span class="line">"pasteImage.path": "$&#123;currentFileDir&#125;/res/",</span><br><span class="line">"pasteImage.prefix": "./",</span><br><span class="line">"pasteImage.defaultName": "Y-MM-DD-HH-mm-ss",</span><br></pre></td></tr></table></figure><h2 id="4-2-Hexo-生成带有图片的-blog"><a href="#4-2-Hexo-生成带有图片的-blog" class="headerlink" title="4.2. Hexo 生成带有图片的 blog"></a>4.2. Hexo 生成带有图片的 blog</h2><p>当待生成 blog 的 markdown 中有图片时, 直接使用 hexo 生成的 Html 是无法正常显示图片的. 因为相对于 html文件而言, 类似于 <code>./res/test.png</code> 的这些路径找不到了. Hexo 是以时间为目录来组织生成的 html 的, 这些 html 分散在很多个以日期标注的文件夹下, 一个个复制到对应文件夹下有点累. 所以笔者的解决方法是, 修改待发布的markdown 中 <code>./res/test.png</code> 为 <code>/res/test.png</code>, 这样只要将用到的图片复制到 hexo 的 <code>source/res/</code> 目录下, hexo 在生成时, 会自动把这些文件拷贝到 html 同级目录中. 这样就能正常显示了.</p><p>这个修改路径的工作可以直接交给脚本去执行. 顺便还能给文件加个公共的Head 和 Tail.</p><p>为了简化 “脚本中查找本文档用到的图片” 逻辑, 笔者在写文档时, 将所有的图片资源引用都放到了文章开头, 格式如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 放于前面</span><br><span class="line"><span class="comment">&lt;!-- RES --&gt;</span></span><br><span class="line">[img1]: /res/mdImg/imgTest.png</span><br><span class="line"><span class="comment">&lt;!-- /RES --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![图片名][img1]</span><br></pre></td></tr></table></figure><h2 id="4-3-使用码云的-web-hooks"><a href="#4-3-使用码云的-web-hooks" class="headerlink" title="4.3. 使用码云的 web hooks"></a>4.3. 使用码云的 web hooks</h2><p>可以使用 node.js 快速搭建一个支持 码云 web hooks 请求的服务. 可以直接引用库 <code>gitee-webhook-handler</code>. 在自己的 js 中调用脚本执行即可.</p><p>如果使用的是其他的 git 仓库, 比如 GitHub, Coding 等, 可以直接引用对应的库来使用. </p><blockquote><p>写在最后, 欢迎读者写下评论, 我们一起交流进步.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
            <tag> 知识管理 </tag>
            
            <tag> Python </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
