<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Qt 中的智能指针</title>
      <link href="/2019/01/08/Qt%20%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2019/01/08/Qt%20%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>友情提示: 你可以选择以下镜像网站进行阅读:</p><ul><li><a href="https://zhaoyongcnsx.github.io" target="_blank" rel="noopener">GitHub Pages</a></li><li><a href="http://www.devved.cn" target="_blank" rel="noopener">个人网站</a></li></ul></blockquote><p><a id="toc_anchor" name="1-Qt智能指针概述"></a></p><h1 id="1-Qt智能指针概述"><a href="#1-Qt智能指针概述" class="headerlink" title="1. Qt智能指针概述"></a>1. Qt智能指针概述</h1><ul><li>Qt 提供了一套基于父子对象的内存管理机制, 所以我们很少需要去手动 delete. 但程序中不一定所有类都是QObject的子类, 这种情况下仍然需要使用一些智能指针. </li><li>注意: 在 Qt 中使用智能指针时, 一定要避免发生多次析构.</li></ul><p><a id="toc_anchor" name="2-Qt中的智能指针分类"></a></p><h1 id="2-Qt中的智能指针分类"><a href="#2-Qt中的智能指针分类" class="headerlink" title="2. Qt中的智能指针分类"></a>2. Qt中的智能指针分类</h1><p>根据不同的使用场景, 可分为以下几种:</p><ul><li><strong>共享数据</strong>. 隐式或显式的共享数据(不共享指针), 也被称为 侵入式指针.<ul><li><code>QSharedDataPointer</code> 指向<strong>隐式共享</strong>对象的指针.</li><li><code>QExplicitlySharedDataPointer</code> 指向<strong>显式共享</strong>对象的指针.</li></ul></li><li><strong>共享指针</strong>. 线程安全.<ul><li><code>QSharedPointer</code>. 有点像 <code>std::shared_ptr</code>, <code>boost::shared_ptr</code>. 维护引用计数, 使用上最像原生指针.</li><li><code>QWeakPointer</code>, 类似于<code>boost::weak_ptr</code>. 作为 <code>QSharedPointer</code> 的助手使用. 未重载<code>*</code>和<code>-&gt;</code>. 用于解决强引用形成的相互引用.</li></ul></li><li><strong>范围指针</strong>. 为了<strong>RAII</strong>[^raii]目的, 维护指针所有权, 并保证其在超出作用域后恰当的被销毁, 非共享.<ul><li><code>QScopedPointer</code>. 相当于 <code>std::unique_ptr</code>.<ul><li>所有权唯一, 其拷贝和赋值操作均为私有. 无法用于容器中.</li></ul></li><li><code>QScopedArrayPointer</code></li></ul></li><li><strong>追踪给定 QObject 对象生命</strong>, 并在其析构时自动设置为 NULL.<ul><li><code>QPointer</code>.</li></ul></li></ul><p><a id="toc_anchor" name="3-共享数据"></a></p><h1 id="3-共享数据"><a href="#3-共享数据" class="headerlink" title="3. 共享数据"></a>3. 共享数据</h1><ul><li>共享数据是为了实现 “读时共享, 写时复制”. 其本质上是延迟了 执行深拷贝 的时机到了需要修改其值的时候. </li><li>C++实现为 在拷贝构造和赋值运算符函数中不直接深度拷贝, 而是维护一个引用计数并获得一个引用或指针. 在需要改变值的方法中再执行深度拷贝.</li><li>隐式共享为, 我们无需管理深度拷贝的时机, 它会自动执行.</li><li>显式共享为, 我们需要人为判断什么时候需要深度拷贝, 并手动执行拷贝.</li><li><code>QSharedData</code> 作为共享数据对象的基类. 其在内部提供 线程安全的引用计数. </li><li>其与 <code>QSharedDataPointer</code> 和 <code>QExplicitlySharedDataPointer</code> 一起使用. </li><li>以上三个类都是可重入的.</li></ul><p><a id="toc_anchor" name="31-隐式共享"></a></p><h2 id="3-1-隐式共享"><a href="#3-1-隐式共享" class="headerlink" title="3.1. 隐式共享"></a>3.1. 隐式共享</h2><ul><li><code>QSharedDataPointer</code>表示指向隐式共享对象的指针. </li><li>其在写操作时, 会<strong>自动调用</strong><code>detach()</code>. 该函数在当共享数据对象引用计数大于1, 会执行深拷贝, 并将该指针指向新拷贝内容. (这是在该类的非 const 成员函数中自动调用的, 我们使用时不需要关心).</li></ul><blockquote><p>比如, 我们现在有一个类 MyClass, 现在要将其改造成支持隐式共享的类.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1   <span class="comment">// MyClass 原始版本</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass()&#123;&#125;</span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;other) &#123;</span><br><span class="line">m_id = other.GetId();</span><br><span class="line">m_path = other.GetPath();</span><br><span class="line">&#125;</span><br><span class="line">~MyClass()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetId</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; m_id = val; &#125;</span><br><span class="line"><span class="function">QString <span class="title">GetPath</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_path; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPath</span><span class="params">(QString val)</span> </span>&#123; m_path = val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_id = <span class="number">-1</span>;</span><br><span class="line">QString m_path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// MyClass 支持隐式共享</span></span></span><br><span class="line"><span class="comment">// 1. 将 MyClass 的所有数据成员都放到 MyClassData 中. </span></span><br><span class="line"><span class="comment">// 2. 在 MyClass 中维护一个 QSharedDataPointer&lt;MyClassData&gt; d.</span></span><br><span class="line"><span class="comment">// 3. MyClass 中通过 d-&gt; 的形式访问数据.</span></span><br><span class="line"><span class="comment">// 4. MyClassData 继承自 QSharedData.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSharedData&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSharedDataPointer&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassData</span> :</span> <span class="keyword">public</span> QSharedData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClassData()&#123;&#125;</span><br><span class="line">MyClassData(<span class="keyword">const</span> MyClassData &amp;other)</span><br><span class="line">: QSharedData(other), id(other.id), path(other.path) &#123;&#125;</span><br><span class="line">~MyClassData()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">QString path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass()&#123; d = <span class="keyword">new</span> MyClassData(); &#125;</span><br><span class="line">MyClass(<span class="keyword">int</span> id, <span class="keyword">const</span> QString &amp; path) &#123;</span><br><span class="line">d = <span class="keyword">new</span> MyClassData();</span><br><span class="line">SetId(id);</span><br><span class="line">SetPath(path);</span><br><span class="line">&#125;</span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;other) : d(other.d)&#123;&#125;</span><br><span class="line">~MyClass()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;id; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetId</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; d-&gt;id = val; &#125;</span><br><span class="line"><span class="function">QString <span class="title">GetPath</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;path; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPath</span><span class="params">(QString val)</span> </span>&#123; d-&gt;path = val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QSharedDataPointer&lt;MyClassData&gt; d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="32-显式共享"></a></p><h2 id="3-2-显式共享"><a href="#3-2-显式共享" class="headerlink" title="3.2. 显式共享"></a>3.2. 显式共享</h2><ul><li><code>QExplicitlySharedDataPointer</code> 表示指向显式共享对象的指针. </li><li>与<code>QSharedDataPointer</code>不同的地方在于, 它不会在非const成员函数执行写操作时, 自动调用 <code>detach()</code>.</li><li>所以需要我们在写操作时, <strong>手动调用</strong> detach(). </li><li>它的行为很像 C++ 常规指针, 不过比指针好的地方在于, 它也维护一套引用计数, 当引用计数为0时会自动设置为 NULL. 避免了悬空指针的危害.</li></ul><blockquote><ul><li>修改上面例子中用到的 QSharedDataPointer 为 QExplicitlySharedDataPointer.</li><li>注意: 如果在使用时发现所有写操作的函数中都调用了 detach(), 那就可以直接使用 QSharedDataPointer 了.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QExplicitlySharedDataPointer&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyClass()&#123; d = <span class="keyword">new</span> MyClassData(); &#125;</span><br><span class="line">MyClass(<span class="keyword">int</span> id, <span class="keyword">const</span> QString &amp; path) &#123;</span><br><span class="line">d = <span class="keyword">new</span> MyClassData();</span><br><span class="line">SetId(id);</span><br><span class="line">SetPath(path);</span><br><span class="line">&#125;</span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass &amp;other) : d(other.d)&#123;&#125;</span><br><span class="line">~MyClass()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;id; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetId</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 需要手动调用 detach()</span></span><br><span class="line">d.detach();</span><br><span class="line">d-&gt;id = val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">GetPath</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> d-&gt;path; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPath</span><span class="params">(QString val)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 需要手动调用 detach()</span></span><br><span class="line">d.detach();</span><br><span class="line">d-&gt;path = val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QExplicitlySharedDataPointer&lt;MyClassData&gt; d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="4-共享指针"></a></p><h1 id="4-共享指针"><a href="#4-共享指针" class="headerlink" title="4. 共享指针"></a>4. 共享指针</h1><p><a id="toc_anchor" name="41-QSharedPointer"></a></p><h2 id="4-1-QSharedPointer"><a href="#4-1-QSharedPointer" class="headerlink" title="4.1. QSharedPointer"></a>4.1. QSharedPointer</h2><ul><li>可用于容器中.</li><li>可提供自定义 Deleter, 所以可用于 <code>delete []</code> 的场景.</li><li>线程安全. 多线程同时修改其对象无需加锁. 但其指向的内存不一定线程安全, 所以多线程同时修改其指向的数据, 还需要加锁.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定 Deleter</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doDeleteLater</span><span class="params">(MyObject *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;deleteLater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestSPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSharedPointer&lt;MyObject&gt; obj(<span class="keyword">new</span> MyObject, doDeleteLater);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 clear 清除引用计数, 并调用 Deleter 删除指针对象.</span></span><br><span class="line">    <span class="comment">// 此处将调用 doDeleteLater</span></span><br><span class="line">    obj.clear();</span><br><span class="line"></span><br><span class="line">    QSharedPointer&lt;MyObject&gt; pObj1 = obj;</span><br><span class="line">    pObj1-&gt;show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pObj1) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------- 实现单例 -------------*/</span></span><br><span class="line"><span class="comment">// cpp 中定义全局变量</span></span><br><span class="line">QSharedPointer&lt;MyObject&gt; g_ptrMyObj;</span><br><span class="line"></span><br><span class="line">QSharedPointer&lt;MyObject&gt; GetMyObj() &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_ptrMyObj.data() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        g_ptrMyObj.reset(<span class="keyword">new</span> MyObject());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_ptrMyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="42-QWeakPointer"></a></p><h2 id="4-2-QWeakPointer"><a href="#4-2-QWeakPointer" class="headerlink" title="4.2. QWeakPointer"></a>4.2. QWeakPointer</h2><ul><li>创建: 只能通过 QSharedPointer 的赋值来创建.</li><li>使用: 不可直接使用. 没有重载<code>*</code>和<code>-&gt;</code>. 需要用 <code>toStrongRef()</code> 转换为 QSharedPointer, 并判断是否为 NULL 之后再使用. <ul><li>可使用 <code>data()</code> 取到指针值, 但不确保其有效. 如果想使用该值, 需用户在外部使用其他手段保证其指针值有效. </li><li>曾经有一段时间, Qt 官方想用 QWeakPointer 取代 QPointer, 但在 Qt5 重写了 QPointer 后, 就不再这么建议了. </li><li>所以使用 QWeakPointer 的最佳场景仍然是: 作为 QSharedPointer 的助手类使用. </li></ul></li></ul><blockquote><ul><li>打开宏 TEST_memory_will_leak, 则因为产生循环引用, 导致内存泄漏, 表现为: 不会打印 “destruct A”, “destruct B”</li><li>关闭宏, 使用 QWeakPointer, 不会产生内存泄漏.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSharedPointer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWeakPointer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_memory_will_leak</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~A() &#123;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"destruct A"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_memory_will_leak</span></span><br><span class="line">QSharedPointer&lt;B&gt; ptr_B;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">QWeakPointer&lt;B&gt; ptr_B;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TEST_memory_will_leak</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~B() &#123;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"destruct B"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_memory_will_leak</span></span><br><span class="line">QSharedPointer&lt;A&gt; ptr_A;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">QWeakPointer&lt;A&gt; ptr_A;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TEST_memory_will_leak</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QSharedPointer&lt;A&gt; nA(<span class="keyword">new</span> A());</span><br><span class="line">QSharedPointer&lt;B&gt; nB(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若内部使用 QSharedPointer, 则此处会形成循环引用.</span></span><br><span class="line">nA-&gt;ptr_B = nB;</span><br><span class="line">nB-&gt;ptr_A = nA;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST_memory_will_leak</span></span><br><span class="line"><span class="keyword">if</span> (!nA-&gt;ptr_B.isNull()) &#123;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"use shared ptr"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (!nA-&gt;ptr_B.toStrongRef().isNull()) &#123;</span><br><span class="line">qDebug() &lt;&lt; <span class="string">"use weak ptr"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> TEST_memory_will_leak</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="5-范围指针"></a></p><h1 id="5-范围指针"><a href="#5-范围指针" class="headerlink" title="5. 范围指针"></a>5. 范围指针</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        QScopedPointer&lt;MyClass&gt; p(<span class="keyword">new</span> MyClass());</span><br><span class="line">        p-&gt;func();</span><br><span class="line">    &#125; <span class="comment">// 退出作用域后析构</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        QScopedArrayPointer&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>] );</span><br><span class="line"></span><br><span class="line">        p[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="comment">// 退出作用域后析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="6-追踪特定QObject对象生命"></a></p><h1 id="6-追踪特定QObject对象生命"><a href="#6-追踪特定QObject对象生命" class="headerlink" title="6. 追踪特定QObject对象生命"></a>6. 追踪特定QObject对象生命</h1><blockquote><p>[***以下描述可搜索 DevBean 的 continue-using-qpointer 一文获取更详细信息***].</p><ul><li>QPointer 在某几个 Qt5 版本中, 被标注为废弃. 且打算使用 QWeakPointer 来代替其原有功能. (为此还允许 QWeakPointer 可独立于 QSharedPointer 使用, 并增加了一系列接口, 引发了接口歧义的副作用). 但经过对 QPointer 的重写后, 解决了之前性能问题, 所以便移除了废弃标志, 并取消了 QWeakPointer 独立使用的相关描述.</li><li>之后还是继续将 QWeakPointer 和 QSharedPointer 捆绑使用. 并继续愉快的使用 QPointer 吧.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelper</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyHelper(QPushButton *btn)</span><br><span class="line">        : m_btn(btn)</span><br><span class="line">        , m_btn2(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetBtn</span><span class="params">(QPushButton *btn)</span> </span>&#123;</span><br><span class="line">        m_btn2 = btn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FuncShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当外部的 QPushButton 析构后, 该值自动设置为 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (m_btn) &#123;</span><br><span class="line">            m_btn-&gt;show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_btn2) &#123;</span><br><span class="line">            m_btn2-&gt;show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPointer&lt;QPushButton&gt; m_btn;</span><br><span class="line">    QPointer&lt;QPushButton&gt; m_btn2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[^raii]: RAII, Resource Acquisition Is Initialization, 资源获取就是初始化. 是 C++ 的一种管理资源, 避免泄漏的惯用方法. 比如, <code>QMutexLocker</code>为了方便管理<code>QMutex</code>的加锁和解锁, 在构造该对象时加锁, 在析构时解锁.</p><blockquote><p>如果本文有幸激发起你的一些思考, 欢迎通过评论的形式给与反馈, 与你与我都是一种成长.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Qt 事件与信号槽</title>
      <link href="/2018/10/13/Qt%20%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
      <url>/2018/10/13/Qt%20%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BF%A1%E5%8F%B7%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>友情提示: 你可以选择以下镜像网站进行阅读:</p><ul><li><a href="https://zhaoyongcnsx.github.io" target="_blank" rel="noopener">GitHub Pages</a></li><li><a href="http://www.devved.cn" target="_blank" rel="noopener">个人网站</a></li></ul></blockquote><p><a id="toc_anchor" name="1-概述"></a></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><ul><li>事件机制比信号槽更底层. 在事件中会默认的发送相应信号, 所以一般使用, 只需操作信号槽即可. </li><li>当我们需要<strong>自定义组件</strong>或<strong>修改现有组件的行为</strong>时, 就需要从事件的层面着手了. </li></ul><p><a id="toc_anchor" name="2-区别"></a></p><h1 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h1><ul><li>信号槽: 其针对的是对象与对象之间的连接. 当信号发射后, 与其相连的槽函数总是会被执行的. </li><li>事件: 可以经过消息队列传输, 也可直接传输. 在传输过程中, 可经过事件过滤器和事件处理函数等手段来干预其. </li></ul><p><a id="toc_anchor" name="3-联系"></a></p><h1 id="3-联系"><a href="#3-联系" class="headerlink" title="3. 联系"></a>3. 联系</h1><ul><li>跨线程的<strong>信号槽</strong>机制是通过<strong>事件机制</strong>完成的. </li><li><p>查看相关 Qt 源码可了解调用过程: </p><blockquote><ul><li>以下情况的信号槽连接会通过 <code>poseEvent()</code>实现: <pre><code>- 信号槽为 `Qt::AutoConnection` 连接模式下    - 发送信号线程非当前线程时  或  信号与槽不在同一线程- 信号槽为 `Qt::QueuedConnection` 连接模式下</code></pre></li></ul></blockquote>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (自动连接模式 &amp;&amp; (信号线程非本线程 || 信号与槽非同一线程) || 对列连接模式)</span></span><br><span class="line"><span class="keyword">if</span> ((c-&gt;connectionType == Qt::AutoConnection</span><br><span class="line">　　     &amp;&amp; (currentThreadData != sender-&gt;d_func()-&gt;threadData</span><br><span class="line">　　         || receiver-&gt;d_func()-&gt;threadData != sender-&gt;d_func()-&gt;threadData))</span><br><span class="line">　　    || (c-&gt;connectionType == Qt::QueuedConnection))</span><br><span class="line">&#123;</span><br><span class="line">    queued_activate(sender, signal, *c, argv);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 阻塞对列模式</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;connectionType == Qt::BlockingQueuedConnection)</span><br><span class="line">&#123;</span><br><span class="line">    blocking_activate(sender, signal, *c, argv);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其中 queued_activate 会调用 :</span></span><br><span class="line">QCoreApplication::postEvent(c.receiver, <span class="keyword">new</span> QMetaCallEvent(c.method, sender, signal, nargs, types, args, semaphore));</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果本文有幸激发起你的一些思考, 欢迎通过评论的形式给与反馈, 与你与我都是一种成长.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Qt 事件 </tag>
            
            <tag> Qt 信号槽 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Qt 事件系统</title>
      <link href="/2018/10/13/Qt%20%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/10/13/Qt%20%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>友情提示: 你可以选择以下镜像网站进行阅读:</p><ul><li><a href="https://zhaoyongcnsx.github.io" target="_blank" rel="noopener">GitHub Pages</a></li><li><a href="http://www.devved.cn" target="_blank" rel="noopener">个人网站</a></li></ul></blockquote><p><a id="toc_anchor" name="1-相关资料"></a></p><h1 id="1-相关资料"><a href="#1-相关资料" class="headerlink" title="1. 相关资料"></a>1. 相关资料</h1><blockquote><p>可查阅 Qt 帮助<code>The Event System</code>和<code>QEvent</code>部分</p></blockquote><ul><li>详细的 Qt 事件系统讲解, 带源码分析: <a href="http://blog.csdn.net/zerokkqq/article/details/6685389" target="_blank" rel="noopener">http://blog.csdn.net/zerokkqq/article/details/6685389</a></li><li>Qt 豆子相关文档: <a href="https://www.devbean.net/2012/10/qt-study-road-2-event-summary/" target="_blank" rel="noopener">https://www.devbean.net/2012/10/qt-study-road-2-event-summary/</a></li></ul><p><a id="toc_anchor" name="2-附件说明"></a></p><h1 id="2-附件说明"><a href="#2-附件说明" class="headerlink" title="2. 附件说明"></a>2. 附件说明</h1><ul><li><a href="./res/Attachments/Qt事件传递过程.xmind">Qt 事件传递过程图解</a></li></ul><p><a id="toc_anchor" name="3-相关类"></a></p><h1 id="3-相关类"><a href="#3-相关类" class="headerlink" title="3. 相关类"></a>3. 相关类</h1><ul><li><code>QAbstractEventDispatcher</code> 事件分发器. </li><li><code>QEvent</code></li><li><code>QCoreApplication</code>, <code>QApplication</code></li><li><code>QEventLoop</code></li></ul><p><a id="toc_anchor" name="4-概述"></a></p><h1 id="4-概述"><a href="#4-概述" class="headerlink" title="4. 概述"></a>4. 概述</h1><ul><li>每个事件均为<code>QEvent</code>子类的一个实例, 每种事件均有一个枚举值用以识别事件类型. 可以使用<code>QEvent::type()</code>来返回事件类型的枚举值, 从而用于比较. <ul><li>可使用 <code>QEvent::registerEventType()</code> 返回一个可用的枚举值. </li></ul></li></ul><p><a id="toc_anchor" name="5-事件分类"></a></p><h1 id="5-事件分类"><a href="#5-事件分类" class="headerlink" title="5. 事件分类"></a>5. 事件分类</h1><ul><li><p>根据事件发生与分发的不同, 可将事件分为三类: </p><ul><li><strong>Spontaneous 事件</strong>,  从系统中得到消息(比如系统的按键, 鼠标等) , 转换为 QEvent 后, 被 Qt 事件系统处理. </li><li><strong>Posted 事件</strong>, 由 Qt 或应用程序产生, 被放入事件队列中 , 再通过事件循环处理. 使用 QCoreApplication::postEvnet() 发送事件. </li><li><strong>Send 事件</strong>, 由 Qt 或应用程序产生, 使用 QCoreApplication::sendEvent() 发送的事件. </li></ul></li><li><p>示例: 窗口的重绘事件处理函数<code>PaintEvent()</code>,  可被以上这三种类型事件调用: </p><ul><li>窗口被覆盖或再次重新显示时, 系统产生自发事件 spontaneous 来请求重绘窗口. </li><li>手动调用<code>update()</code>函数, 产生 Posted 事件, 并放入消息队列. 由事件循环来请求重绘窗口. 该过程会被 Qt 优化(详见 <a href="#wiz://open_document?guid=3f259a9a-bd7c-4f46-919b-7b017edb7a1a&amp;kbguid=&amp;private_kbguid=5575dcb3-4b7d-4cd6-9ea6-b816a3288991">Qt paintEvent()</a>).</li><li>手动调用<code>repaint()</code>函数, 产生 Send 事件, 直接调用该处理函数. 该过程不会被 Qt 优化. </li></ul></li></ul><p><a id="toc_anchor" name="51-Spontaneous事件发送"></a></p><h2 id="5-1-Spontaneous事件发送"><a href="#5-1-Spontaneous事件发送" class="headerlink" title="5.1. Spontaneous事件发送"></a>5.1. Spontaneous事件发送</h2><ul><li>系统底层事件通过<code>QAbstractEventDispatcher</code>转换到 Qt 的事件循环中. </li></ul><p><a id="toc_anchor" name="52-Post事件发送"></a></p><h2 id="5-2-Post事件发送"><a href="#5-2-Post事件发送" class="headerlink" title="5.2. Post事件发送"></a>5.2. Post事件发送</h2><ul><li>需要在<strong>堆上开辟内存</strong>, 用完后会被自动删除. </li><li>使用 postEvent() 将事件放入<strong>事件队列</strong>, 并<strong>立即返回</strong>.</li><li>事件循环 QEventLoop 在空闲时判断事件队列是否为空, 最后使用 sendEvent() 派发这些事件队列中的事件. </li><li>可以手动使用: QCoreApplication::sendPostedEvents() 来派发事件队列中的所有事件(相当于清空了当前事件队列).</li><li><strong>每个线程都有一个事件队列</strong>.</li><li><p>函数原型</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">static</span>] <span class="keyword">void</span> QCoreApplication::postEvent(QObject *receiver,</span><br><span class="line">    QEvent *event,</span><br><span class="line">    <span class="keyword">int</span> priority = Qt::NormalEventPriority);</span><br></pre></td></tr></table></figure></li><li><p>使用示例: </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QApplication::postEvent(mainWin,</span><br><span class="line">    <span class="keyword">new</span> QMouseEvent(QEvent::MouseButtonPress, pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li></ul><p><a id="toc_anchor" name="53-Send事件发送"></a></p><h2 id="5-3-Send事件发送"><a href="#5-3-Send事件发送" class="headerlink" title="5.3. Send事件发送"></a>5.3. Send事件发送</h2><ul><li>需要在<strong>栈上开辟内存</strong>.</li><li>使用 sendEvent() 发送. 该函数会调用 notify() 进行事件分发, 并返回事件执行的<strong>返回值</strong>.</li><li>本过程不涉及 事件队列, 事件循环 等. 但仍可以进行事件过滤, 可使用全部的事件处理手段. </li><li><p>函数原型</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">static</span>] <span class="keyword">bool</span> QCoreApplication::sendEvent(</span><br><span class="line">    QObject *receiver,</span><br><span class="line">    QEvent *event);</span><br></pre></td></tr></table></figure></li><li><p>使用示例: </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMouseEvent <span class="title">event</span><span class="params">(QEvent::MouseButtonPress, pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">QApplication::sendEvent(mainWindow, &amp;event);</span><br></pre></td></tr></table></figure></li></ul><p><a id="toc_anchor" name="6-事件发送"></a></p><h1 id="6-事件发送"><a href="#6-事件发送" class="headerlink" title="6. 事件发送"></a>6. 事件发送</h1><ul><li>事件分发器 <code>QAbstractEventDispatcher</code> 管理着 Qt 的事件队列, 从系统或其他事件源接收事件, 再发送给 QCoreApplication 或 QApplication 实例来进行处理. </li></ul><p><a id="toc_anchor" name="61-直接派发"></a></p><h2 id="6-1-直接派发"><a href="#6-1-直接派发" class="headerlink" title="6.1. 直接派发"></a>6.1. 直接派发</h2><ul><li>sendEvent 事件通过调用 QApplication::notify() 分发, 直接进入事件的派发和处理. </li></ul><p><a id="toc_anchor" name="62-通过**事件循环**方式"></a></p><h2 id="6-2-通过事件循环方式"><a href="#6-2-通过事件循环方式" class="headerlink" title="6.2. 通过事件循环方式"></a>6.2. 通过<strong>事件循环</strong>方式</h2><blockquote><p>postEvent 和 自发事件</p></blockquote><ul><li>Qt 主线程事件循环<ul><li>使用 QCoreApplication::exec() 启动. </li><li>在 QCoreApplication::exit() 后退出. </li></ul></li><li>本地事件循环使用 QEventLoop 构建. </li></ul><p><a id="toc_anchor" name="621-事件循环源码解析"></a></p><h3 id="6-2-1-事件循环源码解析"><a href="#6-2-1-事件循环源码解析" class="headerlink" title="6.2.1. 事件循环源码解析"></a>6.2.1. 事件循环源码解析</h3><ul><li><p>步骤</p><ol><li>处理 <strong>Qt 事件队列</strong>中的事件(也就是 post 事件), 直至为空. </li><li>处理<strong>系统消息队列</strong>中的消息(也就是自发事件), 直至为空. </li><li>执行第 2 步时, 会产生新的 Qt 事件, 然后继续处理 Qt 事件队列中的事件. </li></ol></li><li><p>源码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!exit_was_called) &#123;</span><br><span class="line">    <span class="comment">// 处理事件队列 中的事件</span></span><br><span class="line">    <span class="keyword">while</span> (!posted_event_queue_is_empty) &#123;</span><br><span class="line">        process_next_posted_event();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(自发事件) 处理 系统消息队列 中的消息  (在处理过程中产生新的 Qt 事件)</span></span><br><span class="line">    <span class="keyword">while</span> (!spontaneous_event_queue_is_empty) &#123;</span><br><span class="line">        process_next_spontaneous_event();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对新产生的事件进行处理</span></span><br><span class="line">    <span class="keyword">while</span> (!posted_event_queue_is_empty) &#123;</span><br><span class="line">        process_next_posted_event();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a id="toc_anchor" name="7-事件传递"></a></p><h1 id="7-事件传递"><a href="#7-事件传递" class="headerlink" title="7. 事件传递"></a>7. 事件传递</h1><ul><li>一个事件产生后, 会先传送给最上层的<strong>子控件</strong>, 若在这个传送过程中没有被标记为被处理, 将会继续传送给其<strong>父控件组</strong>中其他可接受该事件的控件, 直到该事件被标记为已处理, 或到最顶层窗体. </li><li>事件的传播是在<strong>组件层次</strong>上面的, 而不是依靠类继承机制. eg: 若该组件不接受本事件, 则会继续传递给其父组件列表中能处理该事件的组件, 而不是父对象. </li></ul><p><a id="toc_anchor" name="71-过程"></a></p><h2 id="7-1-过程"><a href="#7-1-过程" class="headerlink" title="7.1. 过程"></a>7.1. 过程</h2><ul><li>一个事件产生后, 会根据<em>事件类型</em> 不同, 而被以不同的方式分发出去. </li><li>不同方式分发出去的事件, 最终都要经过 <code>QCoreApplication::notify()</code> 来对事件进行处理. </li><li>在 notify() 函数中, 先要将本事件传递给 receiver 处理. <ul><li>如果在本 QCoreApplication 安装了事件过滤器, 本程序中发送给所有对象的事件都要经过这些事件过滤器处理. 若在其中<strong>都</strong>没有 return, 则继续传递. </li><li>如果在 receiver 安装了事件过滤器, 发送给该 receiver 的事件要先经过这些事件过滤器处理. 若在其中<strong>都</strong>没有 return, 则继续传递. </li><li>传递给 receiver 的 event() 函数进行处理. 若该事件为自定义事件, 会在函数中调用 customEvent() 函数. 而其他 Qt 事件, 一般会分发给其他 event handler 函数. </li><li>传递到特定 event handler 函数, 在其中对事件进行处理. <ul><li>event-&gt;accept(), 本事件传递结束. </li><li>event-&gt;ignore(), 本事件继续向 receiver 的父控件传递. </li></ul></li></ul></li><li>传递本事件给 receiver 的父控件们, 直到传递过程被终止 (return), 事件被 accept, 或 到达顶层窗体. </li></ul><p><a id="toc_anchor" name="72-终止事件传递的方法"></a></p><h2 id="7-2-终止事件传递的方法"><a href="#7-2-终止事件传递的方法" class="headerlink" title="7.2. 终止事件传递的方法"></a>7.2. 终止事件传递的方法</h2><ul><li><code>QApplication::notify()</code> 有 bool 返回值<ul><li>只要返回, 就会终止事件传递过程. 且如果是 sendEvent(), 会返回值. </li></ul></li><li><code>QObject::eventFilter()</code>, <code>QObject::event()</code> 有 bool 返回值. <ul><li>return true : 表示事件已被处理, 不会继续传递</li><li>return false : 表示事件需要继续传递</li></ul></li><li>对于各事件处理函数 (eg: mouseReleaseEvent()), 无返回值. <ul><li>event-&gt;accept() : 表示事件已被处理, 不会继续传递</li><li>event-&gt;ignore() : 表示事件需要继续传递</li></ul></li></ul><p><a id="toc_anchor" name="8-`notify()`"></a></p><h1 id="8-notify"><a href="#8-notify" class="headerlink" title="8. notify()"></a>8. <code>notify()</code></h1><ul><li>不论是哪种事件, 最后都由 notify() 负责派发. </li><li>在 notify 中, 负责调用各事件过滤器, event() 等. 可在本源码中明白事件传递的过程. </li></ul><p><a id="toc_anchor" name="81-notify相关源码解析"></a></p><h2 id="8-1-notify相关源码解析"><a href="#8-1-notify相关源码解析" class="headerlink" title="8.1. notify相关源码解析"></a>8.1. notify相关源码解析</h2><ul><li>QApplication 重写了 QCoreApplication 的 notify(). 实现了众多 event 的分发. </li><li>每个 event 分发过程类似, 都会遍历 receiver 及其 父控件们. 直到中断整个事件传递过程. </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QCoreApplication::notify(QObject *receiver, QEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// no events are delivered after ~QCoreApplication() has started</span></span><br><span class="line">    <span class="keyword">if</span> (QCoreApplicationPrivate::is_app_closing)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> doNotify(receiver, event);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">doNotify</span><span class="params">(QObject *receiver, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="number">0</span>) &#123;                        <span class="comment">// serious error</span></span><br><span class="line">        qWarning(<span class="string">"QCoreApplication::notify: Unexpected null receiver"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... 省略了一些内容</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> receiver-&gt;isWidgetType() ? <span class="literal">false</span> : QCoreApplicationPrivate::notify_helper(receiver, event);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将事件传递给事件过滤器和接受者</span></span><br><span class="line"><span class="keyword">bool</span> QCoreApplicationPrivate::notify_helper(QObject *receiver, QEvent * event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*--- 1. 发送给所有 Application 的 eventFilter  ---*/</span></span><br><span class="line">    <span class="comment">// send to all application event filters (only does anything in the main thread)</span></span><br><span class="line">    <span class="keyword">if</span> (QCoreApplication::self</span><br><span class="line">            &amp;&amp; receiver-&gt;d_func()-&gt;threadData-&gt;thread == mainThread()</span><br><span class="line">            &amp;&amp; QCoreApplication::self-&gt;d_func()-&gt;sendThroughApplicationEventFilters(receiver, event))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--- 2. 发送给所有 receiver 的 eventFilter   ---*/</span></span><br><span class="line">    <span class="keyword">if</span> (sendThroughObjectEventFilters(receiver, event))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--- 3. 调用接受者的 event   ---*/</span></span><br><span class="line">    <span class="keyword">return</span> receiver-&gt;event(event);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> QApplication::notify(QObject *receiver, QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> QEvent::ToolTip:</span><br><span class="line">    <span class="keyword">case</span> QEvent::WhatsThis:</span><br><span class="line">    <span class="keyword">case</span> QEvent::QueryWhatsThis:</span><br><span class="line">        &#123;</span><br><span class="line">            QWidget* w = <span class="keyword">static_cast</span>&lt;QWidget *&gt;(receiver);    <span class="comment">// 接受者</span></span><br><span class="line">            QHelpEvent *help = <span class="keyword">static_cast</span>&lt;QHelpEvent*&gt;(e);</span><br><span class="line">            QPoint relpos = help-&gt;pos();</span><br><span class="line">            <span class="keyword">bool</span> eventAccepted = help-&gt;isAccepted();</span><br><span class="line">            <span class="keyword">while</span> (w) &#123;    <span class="comment">// 遍历接受者及其父控件</span></span><br><span class="line">                QHelpEvent he(help-&gt;type(), relpos, help-&gt;globalPos());</span><br><span class="line">                he.spont = e-&gt;spontaneous();    <span class="comment">// 是否为自发事件</span></span><br><span class="line">                <span class="comment">// 发送本事件到某控件, 并接受返回值</span></span><br><span class="line">                res = d-&gt;notify_helper(w, w == receiver ? help : &amp;he);</span><br><span class="line">                e-&gt;spont = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 查看事件是否 accept</span></span><br><span class="line">                eventAccepted = (w == receiver ? help : &amp;he)-&gt;isAccepted();</span><br><span class="line">                <span class="comment">// 返回 true, 且事件被 accept 或 本控件为一个独立的窗体 则不继续传递该事件</span></span><br><span class="line">                <span class="keyword">if</span> ((res &amp;&amp; eventAccepted) || w-&gt;isWindow())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                relpos += w-&gt;pos();</span><br><span class="line">                w = w-&gt;parentWidget();</span><br><span class="line">            &#125;</span><br><span class="line">            help-&gt;setAccepted(eventAccepted);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="9-`event()`"></a></p><h1 id="9-event"><a href="#9-event" class="headerlink" title="9. event()"></a>9. <code>event()</code></h1><ul><li>源码如下: </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QObject::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;type()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Timer:</span><br><span class="line">        timerEvent((QTimerEvent*)e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::ChildAdded:</span><br><span class="line">    <span class="keyword">case</span> QEvent::ChildPolished:</span><br><span class="line">    <span class="keyword">case</span> QEvent::ChildRemoved:</span><br><span class="line">        childEvent((QChildEvent*)e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::DeferredDelete:</span><br><span class="line">        qDeleteInEventHandler(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MetaCall: &#123;</span><br><span class="line">            <span class="comment">//... 省略</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> QEvent::ThreadChange: &#123;</span><br><span class="line">        <span class="comment">//... 省略</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 自定义事件</span></span><br><span class="line">        <span class="keyword">if</span> (e-&gt;type() &gt;= QEvent::User) &#123;</span><br><span class="line">            customEvent(e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果本文有幸激发起你的一些思考, 欢迎通过评论的形式给与反馈, 与你与我都是一种成长.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Qt 事件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Qt 对于事件的自定义处理</title>
      <link href="/2018/10/13/Qt%20%E5%AF%B9%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86/"/>
      <url>/2018/10/13/Qt%20%E5%AF%B9%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>友情提示: 你可以选择以下镜像网站进行阅读:</p><ul><li><a href="https://zhaoyongcnsx.github.io" target="_blank" rel="noopener">GitHub Pages</a></li><li><a href="http://www.devved.cn" target="_blank" rel="noopener">个人网站</a></li></ul></blockquote><p><a id="toc_anchor" name="1-概述"></a></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><ul><li>已知了事件传递的过程, 可针对每个环节来自定义事件的处理. 有五个层次来自定义处理事件. </li></ul><p><a id="toc_anchor" name="11-程序示例"></a></p><h2 id="1-1-程序示例"><a href="#1-1-程序示例" class="headerlink" title="1.1. 程序示例"></a>1.1. 程序示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> :</span> <span class="keyword">public</span> QApplication</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    MyApplication(<span class="keyword">int</span> &amp;argc, <span class="keyword">char</span> **argv): QApplication(argc, argv) &#123; &#125;</span><br><span class="line">    ~MyApplication() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/*--- [1] application notify ---*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">notify</span><span class="params">(QObject *object, QEvent *event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;type() == QEvent::MouseButtonRelease) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"[notify]"</span> &lt;&lt; <span class="string">"objName: "</span> &lt;&lt; object-&gt;objectName();</span><br><span class="line">            <span class="comment">// return false; return true;  只要 return, 该 event 就不会继续传递</span></span><br><span class="line">            <span class="comment">// 若需要继续分发该 event, 则需执行 QApplication::notify</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QApplication::notify(object, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFilter</span>:</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassFilter(QObject *parent = <span class="number">0</span>) : QObject(parent) &#123;&#125;</span><br><span class="line">    ~ClassFilter() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;type() == QEvent::MouseButtonRelease) &#123;</span><br><span class="line">            qDebug() &lt;&lt; QString::fromUtf8(<span class="string">"[eventFilter] [%1] "</span>).arg(objectName())  &lt;&lt; <span class="string">"objName: "</span> &lt;&lt; watched-&gt;objectName();</span><br><span class="line">            <span class="comment">//return true;  // 事件终止传递</span></span><br><span class="line">            <span class="comment">//return false; // 事件继续传递</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QObject::eventFilter(watched, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> :</span> <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyButton(QWidget *parent = <span class="number">0</span>): QPushButton(parent) &#123;&#125;</span><br><span class="line">    ~MyButton() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/*--- [4] 事件接受者的 event ---*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">event</span><span class="params">(QEvent *e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;type() == QEvent::MouseButtonRelease) &#123;</span><br><span class="line">            qDebug() &lt;&lt; QString::fromUtf8(<span class="string">"[event]"</span>);</span><br><span class="line">            <span class="comment">//return true;      // 事件终止传递</span></span><br><span class="line">            <span class="comment">//return false;     // 事件继续向父控件传递</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QPushButton::event(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*--- [5] 事件接受者的 event Handle ---*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"[event Handle]"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根据需求判断是否需要调用父类 event Handler</span></span><br><span class="line">        QPushButton::mouseReleaseEvent(event);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//event-&gt;accept();      // 事件终止传递</span></span><br><span class="line">        <span class="comment">//event-&gt;ignore();      // 事件继续向父控件传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUI</span>:</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyUI(QWidget *parent = <span class="number">0</span>): QWidget(parent) &#123;</span><br><span class="line">        QPushButton *btn = <span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">        btn-&gt;setObjectName(<span class="string">"pushButton"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*--- [3] 在组件上安装事件过滤器 ---*/</span></span><br><span class="line">        ClassFilter* filterWgt = <span class="keyword">new</span> ClassFilter(<span class="keyword">this</span>);</span><br><span class="line">        filterWgt-&gt;setObjectName(<span class="string">"filterWgt"</span>);</span><br><span class="line">        btn-&gt;installEventFilter(filterWgt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"> </span><br><span class="line">    MyUI w;</span><br><span class="line">    w.show();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--- [2] 在 application 安装事件过滤器 ---*/</span></span><br><span class="line">    ClassFilter filterApp;</span><br><span class="line">    filterApp.setObjectName(<span class="string">"filterApp"</span>);</span><br><span class="line">    a.installEventFilter(&amp;filterApp);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行结果</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[notify] objName:  <span class="string">"MyUIClassWindow"</span></span><br><span class="line"><span class="string">"[eventFilter] [filterApp] "</span> objName:  <span class="string">"MyUIClassWindow"</span></span><br><span class="line">[notify] objName:  <span class="string">"pushButton"</span></span><br><span class="line"><span class="string">"[eventFilter] [filterApp] "</span> objName:  <span class="string">"pushButton"</span></span><br><span class="line"><span class="string">"[eventFilter] [filterWgt] "</span> objName:  <span class="string">"pushButton"</span></span><br><span class="line"><span class="string">"[event]"</span></span><br><span class="line">[event Handle]</span><br></pre></td></tr></table></figure></li></ul><p><a id="toc_anchor" name="2-重写receiverEventHandler"></a></p><h1 id="2-重写receiverEventHandler"><a href="#2-重写receiverEventHandler" class="headerlink" title="2. 重写receiverEventHandler"></a>2. 重写receiverEventHandler</h1><ul><li>这是最普通简单的方法. 实现的功能也最简单, 且仅可用于有独立事件处理器的事件(很多不常用的事件就直接在<code>event()</code>中被处理了)</li><li>注意: 需时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！不注意这个将可能产生很难调的 Bug.<ul><li>eg: 有一个类 A, 继承自 QPushButton. 在类 A 中将他的 clicked() 信号关联到了槽 slot_a(). 又重写了该类的 mousePressEvent 回调函数. 在该函数中并没有调用父类的同名函数 QPushButton::mousePressEvent(). 因为 QPushButton 的 clicked 信号在 QPushButton::mousePressEvent() 中发出, 而该函数并未执行. 所以按钮的 clicked 信号将永远不会发出. slot_a() 也将永远不会被执行. </li></ul></li></ul><p><a id="toc_anchor" name="21-`accept()`和`ignore()`"></a></p><h2 id="2-1-accept-和ignore"><a href="#2-1-accept-和ignore" class="headerlink" title="2.1. accept()和ignore()"></a>2.1. <code>accept()</code>和<code>ignore()</code></h2><ul><li>调用该事件的<code>accept()</code>, 则这个事件就不会被继续传播给其父组件. </li><li>调用该事件的<code>ignore()</code>, Qt 会从其父组件中寻找另外的接受者. </li></ul><p><a id="toc_anchor" name="211-使用"></a></p><h3 id="2-1-1-使用"><a href="#2-1-1-使用" class="headerlink" title="2.1.1. 使用"></a>2.1.1. 使用</h3><blockquote><p>Tips: 当自己重写了事件处理函数时, 若想这个事件继续传播, 则调用父类的该事件处理函数. 若想事件就此打住, 则不用调用父类的事件处理函数. </p></blockquote><ul><li><p>其实自己很少手动调用这两种方法, 当我们想忽略该事件时, 只需调用父类的相应事件处理函数即可. 因为我们不知道父类中的实现. 若我们在子类中直接忽略该事件, 则父类将接收不到该事件. 所以应尽量调用父类取实现. </p></li><li><p>为此 Qt 有默认的设计: </p><ul><li>事件对象默认为<code>accept()</code>的. </li><li>所有组件的父类<code>QWidget</code>默认的实现则是调用<code>ignore()</code></li></ul></li><li><p>这样, 若在自己实现的事件处理函数中, 不调用 QWidget 的事件处理函数, 就相当于调用了<code>accept()</code>. 若想忽略信号, 则直接调用 QWidget 的事件处理函数. </p></li><li><p>必须手动调用的特殊场景: </p><ul><li>对于窗口关闭事件<code>QCloseEvent</code>:<ul><li><code>accept()</code>的调用意味着 Qt 将停止事件的传播, 窗口关闭. </li><li><code>ignore()</code>的调用意味着事件继续传播, 阻止窗口关闭. </li></ul></li></ul></li></ul><p><a id="toc_anchor" name="3-重写接收者的`event()`函数"></a></p><h1 id="3-重写接收者的event-函数"><a href="#3-重写接收者的event-函数" class="headerlink" title="3. 重写接收者的event()函数"></a>3. 重写接收者的<code>event()</code>函数</h1><ul><li>event() 函数负责将到来的所有 event 按照 event-&gt;type() 不同, 分发给不同的 event Handler. </li><li>可达到的效果: 自定义事件的分发. </li></ul><p><a id="toc_anchor" name="31-作用"></a></p><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1. 作用"></a>3.1. 作用</h2><ul><li>重写该组件的<code>event()</code>后, 在分发到各 event Handler 之前, 完成一些自定义的事情. 如下: <ol><li>直接在该函数中写入对关系的事件的自定义处理. 不用一个一个重写各种事件处理器了. (但若在父类的 event() 调用问题上出错, 将有很大的影响. )</li><li>直接屏蔽掉一些不关心的事件. ( QEvent::type() 判断之后, 在不关心的 case 分支下什么都不写. )</li></ol></li></ul><p><a id="toc_anchor" name="32-缺点"></a></p><h2 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2. 缺点"></a>3.2. 缺点</h2><ul><li>虽然可以在<code>event()</code>中屏蔽掉不关心的事件. 但是当需要屏蔽事件的组件很多时, 工程量巨大. (eg: 所有组件都不响应鼠标事件, 则需要在所有组件中都重写 event(), 在 event() 中不分发鼠标事件).</li><li>所以 Qt 提供了 eventFilter (事件过滤器). 只需将主窗体中为你每个部件都<code>installEventFilter(主窗体)</code>之后, 重写主窗体的<code>eventFilter()</code>, 在其中屏蔽掉鼠标事件即可. </li></ul><p><a id="toc_anchor" name="33-代码实例"></a></p><h2 id="3-3-代码实例"><a href="#3-3-代码实例" class="headerlink" title="3.3. 代码实例"></a>3.3. 代码实例</h2><blockquote><p>只处理 tab 按键事件, 其他都不处理(因为所有信号都未分发)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CustomTextEdit::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;type() == QEvent::KeyPress) &#123;    <span class="comment">// 事件</span></span><br><span class="line">        QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab) &#123;    <span class="comment">// 只接受 tab</span></span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"You press tab."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只对 tab 事件做了特殊处理(处理后屏蔽). 其他事件不受影响(其他信号分发)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (e-&gt;type() == QEvent::KeyPress) &#123;    <span class="comment">// 事件</span></span><br><span class="line">        QKeyEvent *keyEvent = <span class="keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab) &#123;    <span class="comment">// 只接受 tab</span></span><br><span class="line">            qDebug() &lt;&lt; <span class="string">"You press tab."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 不会再传递</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 父类: :event();    <span class="comment">// 其他事件, 不受影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="4-事件过滤器"></a></p><h1 id="4-事件过滤器"><a href="#4-事件过滤器" class="headerlink" title="4. 事件过滤器"></a>4. 事件过滤器</h1><ul><li><p>每个 QObject 对象都维护一个 <code>QObjectList eventFilters;</code> 成员变量. </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">QObject *a = <span class="keyword">new</span> QObject;</span><br><span class="line">QObject *b = <span class="keyword">new</span> QObject;</span><br><span class="line"><span class="comment">// 在 a 上安装事件过滤器 b.</span></span><br><span class="line"><span class="comment">// b 被存储在 a 的成员变量 eventFilters 中. </span></span><br><span class="line">a-&gt;installEventFilter(b);</span><br></pre></td></tr></table></figure></li></ul><ul><li>当事件到达对象 A 的<code>event()</code>之后, 会根据事件类型传递给 A 的各事件处理函数. 但可以在 A 上安装事件过滤器 <code>A-&gt;installEventFilter(B);</code> , 使得 A 的这些事件在到达事件处理函数之前, 先被对象 B 的<code>eventFilter()</code>进行处理. </li><li>根据被安装事件过滤器的对象, 可分为以下两种: <ul><li>在<code>QCoreApplication::instance()</code>, 也就是<code>qApp</code>上面安装事件过滤器. 这样该应用程序的所有事件将经过该事件过滤函数的过滤. </li><li>在其他对象上安装事件过滤器, 只有发送给该对象的事件会被该事件过滤函数过滤. </li></ul></li></ul><p><a id="toc_anchor" name="41-优缺点"></a></p><h2 id="4-1-优缺点"><a href="#4-1-优缺点" class="headerlink" title="4.1. 优缺点"></a>4.1. 优缺点</h2><ul><li>优点: <ul><li>不用继承该控件, 就能自定义处理其事件. 因为各事件处理函数为 protected, 外部无法直接访问. 而安装事件过滤器就能在 事件处理函数 之前, 处理事件. </li></ul></li><li>缺点: <ul><li>只能用于<strong>单线程</strong>.  事件过滤器和被安装过滤器的组件必须在<strong>同一线程</strong>, 否则, 过滤器将不起作用. 另外, 如果在安装过滤器之后, 这两个组件到了不同的线程, 那么, 只有等到二者重新回到同一线程的时候过滤器才会有效. </li></ul></li></ul><p><a id="toc_anchor" name="42-方法"></a></p><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2. 方法"></a>4.2. 方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line"><span class="keyword">void</span> QObject::installEventFilter(QObject * filterObj);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 卸载</span></span><br><span class="line"><span class="keyword">void</span> QObject::removeEventFilter(QObject * obj);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 事件过滤函数</span></span><br><span class="line"><span class="comment">// 返回值: 不想该事件被继续传递下去(包括发送给 receiver), 返回 true. 否则返回 false.</span></span><br><span class="line"><span class="comment">// 注意: 若在事件过滤函数中 delete 了某个组件, 则必须返回`true`. 否则 Qt 还将事件分发给这个组件, 程序崩溃</span></span><br><span class="line"><span class="keyword">bool</span> QObject::eventFilter(QObject * watched, QEvent * event) [<span class="keyword">virtual</span>];</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="43-特别注意"></a></p><h2 id="4-3-特别注意"><a href="#4-3-特别注意" class="headerlink" title="4.3. 特别注意"></a>4.3. 特别注意</h2><ul><li><p>在 <code>QAbstractScollArea</code> 及其子类上安装事件过滤器时, 要安装在其<strong>视口</strong>上. </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit edit;</span><br><span class="line">edit.installEventFilter(<span class="keyword">this</span>);</span><br><span class="line">edit.viewPort()-&gt;installEventFilter(<span class="keyword">this</span>);    <span class="comment">// 在视口上安装事件过滤器</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watcher, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (watcher == edit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;type == QEvent::KeyPress) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidgert::eventFilter(watcher, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个控件或 qApp 安装了多个事件过滤器</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">btn-&gt;installEventFilter(A);</span><br><span class="line">btn-&gt;installEventFilter(B);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// B::eventFilter 先收到, 不做处理时, A::eventFilter 收到</span></span><br><span class="line"> </span><br><span class="line">qApp-&gt;installEventFilter(A);</span><br><span class="line">qApp-&gt;installEventFilter(B);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// B::eventFilter 先收到, 不做处理时, A::eventFilter 收到</span></span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="5-重写`notify()`函数"></a></p><h1 id="5-重写notify-函数"><a href="#5-重写notify-函数" class="headerlink" title="5. 重写notify()函数"></a>5. 重写<code>notify()</code>函数</h1><ul><li>这种方法是影响最大的方法, 因为该函数负责将事件发送给接收者. </li><li>该方法不受线程限制, 其可用于<strong>多线程</strong>. 但是全局范围内只能有一个被使用(因为 QCoreApplication 是单例的). </li><li>QApplication 重写了 QCoreApplication 的 notify(). 具体可查看上一节的源码分析部分. </li><li>根据本程序是 QCoreApplication 还是 QAPplication, 选择子类化哪个类. </li></ul><blockquote><p>如果本文有幸激发起你的一些思考, 欢迎通过评论的形式给与反馈, 与你与我都是一种成长.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Qt 事件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建属于自己的知识管理系统</title>
      <link href="/2018/10/07/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/10/07/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>友情提示: 你可以选择以下镜像网站进行阅读:</p><ul><li><a href="https://zhaoyongcnsx.github.io" target="_blank" rel="noopener">GitHub Pages</a></li><li><a href="http://www.devved.cn" target="_blank" rel="noopener">个人网站</a></li></ul></blockquote><!-- URL --><!-- /URL --><p><a id="toc_anchor" name="1-问题描述"></a></p><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>众所周知, 搭建自己的知识管理系统是十分重要的. </p><p>笔者对知识管理系统的需求有以下几点:</p><ul><li>支持多平台. PC, 移动端都得有. 移动端编辑功能可以弱一点, 但是查找功能不能弱. 毕竟移动端最大的使用场景就是随时随地找找笔记.</li><li>支持扩展. 除非功能十分强大, 不然就要对扩展有良好的支持. 总不能软件自身 Markdown 渲染的那么丑, 还不让人自定义吧.</li><li>数据安全性. 这倒不是说笔记有啥机密, 主要都是自己写的东西, 莫名奇妙的丢了也挺心疼的. </li><li>平台可替代性. 如果这家公司倒闭了呢, 总得让我能很方便的把数据导出去吧, 最好能直接把 Markdown 导出, 这样导入到其他软件也很方便. </li></ul><p>以下是对一些软件使用后的吐槽…</p><ul><li>为知笔记: 笔者是一个购买了多年为知笔记的用户, 其各平台客户端功能完成度都不错. 虽然 Markdown 编辑器烂成渣, 不过可以在笔记中添加使用第三方编辑器. 这一点还是值得给点赞的. 而为知最大的不足就是搜索. Markdown 笔记内容搜索体验很差. 而且近年感觉为知的更新速度放缓了, 论坛也很少有回复了, 有种渐行渐远的感觉… </li><li>有道云笔记: 搜索渣的连为知都不如, 虽然体量很大, 但体验确实做得不好.</li><li>Leanote: 刚开始接触 Leanote 时, 有种被惊艳到的感觉. 优良的 Markdown 编辑体验, 自带 blog 展示. 还是开源软件, 不仅客户端开源, 服务器端也开源了. 笔者于是很快搭建了自己的 Leanote 服务. 可等到新鲜劲过去之后, 问题也暴露的越来越多. 它的 安卓 和 ios 客户端功能完成度很低. 而且查了下 gitHub, 都有一年以上没更新了… 再加上自建服务器稳定性有待商榷, 所以还是弃坑了. </li><li>VNote: 本地功能很强大, 但是好像目前还没有做同步 和 移动端软件.</li><li>…</li></ul><p><a id="toc_anchor" name="2-方案设计"></a></p><h1 id="2-方案设计"><a href="#2-方案设计" class="headerlink" title="2. 方案设计"></a>2. 方案设计</h1><p>现有的笔记类软件很难满足要求. 在一个个软件的使用和比较中, 总在做着艰难的取舍. 就没有一个符合自己全部要求的方案吗? 有, 那就是自己搞一个! </p><p>历史总是惊人的相似, 轮子总是重复的创造…</p><p>如果从 PC 到 移动端 再到 服务器 完整打造一套软件系统, 所花费的时间成本太大了. 而比较现实的方案是: 先应用一些现有的软件, 辅以扩展性良好的通用数据结构, 打造能基本满足需求的系统. 等之后再从短板开始进行逐一替换.</p><p>那就先说说这个现有的实现方案吧. 使用体验上虽然还不完美, 但也绝对比之前的体验要好. </p><ul><li>使用 Markdown 作为笔记格式, 使用单纯的目录结构来管理笔记.</li><li>使用 git 负责笔记同步, 国内可选择同步到 <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 等平台. 可以设置 git 项目属性为 private. </li><li>使用 Hexo 生成博客, 托管到 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> 上. </li><li>Win, Mac 下, 可使用<code>VS Code</code>加载笔记文件夹, 且可以通过安装插件, 完成 Markdown 图片粘贴, git 快速同步, Markdown 高级预览.</li><li>ios 下, 有很多支持 git 的软件, 试用了一圈发现还是<code>Working Copy</code>更符合我的使用习惯. 主要是因为其支持 查找文档内容 和 Markdown 预览. 虽然 Markdown 预览有些瑕疵, 但是不影响使用.</li><li>运行在自己服务器中的一些脚本, 用于自动更新 Hexo 生成 blogs.</li></ul><p><a id="toc_anchor" name="3-效果体现"></a></p><h1 id="3-效果体现"><a href="#3-效果体现" class="headerlink" title="3. 效果体现"></a>3. 效果体现</h1><p>忙活了好几天, 终于完成了. 最后达到的效果是: </p><ul><li>在任一客户端更改笔记后, 将笔记 push 到码云. </li><li>这会触发一个预先在码云该项目中设置了的 web hook, 它会发送一个 POST 请求到笔者的服务器. </li><li>在该服务器上运行着一个 Node.js 服务. 当收到请求时, 会执行:<ol><li>pull 笔记到本地, 读取文档中的一个配置文件. 该文件说明了 blogs 的生成规则, 包括哪些笔记要生成 blogs, 用到哪些 tags, 是否接受评论, …</li><li>将这些待发布为 blog 的笔记做一些特殊处理后, 生成 md 文件到 Hexo source 目录下. </li><li>复制这些 md 文件中用到的图片到 Hexo source 目录下.</li><li>调用 Hexo 生成 Html 文件. 再 push 到 GitHub Pages 中.</li><li>自动发送邮件给笔者, 通知执行结果, 并把日志文件以附件形式包含在邮件中.</li></ol></li></ul><p><a id="toc_anchor" name="4-实现过程中的问题记录"></a></p><h1 id="4-实现过程中的问题记录"><a href="#4-实现过程中的问题记录" class="headerlink" title="4. 实现过程中的问题记录"></a>4. 实现过程中的问题记录</h1><p>在整个过程中, 遇到了一些问题, 积累点滴, 以供成长.</p><p><a id="toc_anchor" name="41-在Markdown中插入图片和附件"></a></p><h2 id="4-1-在Markdown中插入图片和附件"><a href="#4-1-在Markdown中插入图片和附件" class="headerlink" title="4.1. 在Markdown中插入图片和附件"></a>4.1. 在Markdown中插入图片和附件</h2><p>在 Markdown 文档中插入图片, 一直是一个痛点. 而现有软件的解决思路一般有以下几种:</p><ul><li>插入图片时, 将图片传到自己服务器, 并返回一个 URL. 和使用<strong>网络图床</strong>的解决方法一致.</li><li>插入图片时, 将图片复制到一个指定路径, 并返回该路径. 同步时, 将图片和文档一起同步. </li></ul><p>方案一中管理图片时, 需要先登录到图床, 再进行修改. 万一哪天图床挂了, 图床之间的迁移成本太高了. 所以笔者采用了方案二. 具体做法是: 在笔记的同级目录, 创建文件夹 res, 将图片拷贝到该文件夹下. 在 note1.md 中使用 <code>![图片标题](./Res/img1.png)</code> 的方式来引用该图片. 目录结构示意图如下:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res</span><br><span class="line"> <span class="string">|-- img1.png</span></span><br><span class="line"></span><br><span class="line">note1.md</span><br></pre></td></tr></table></figure><p>VS Code 可使用 <code>Paste Image</code> 插件将剪切板的图像生成图片文件, 存储到特定目录下, 再将路径插入到文档中. 可使用 <code>Markdown Preview Enhanced</code> 来选择现有的图片插入. 该插件会将图片复制到指定目录, 并在文档中增加内容. 只需要在安装完插件后, 增加配置如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//----------------- markdown preview Enhanced -------------------</span><br><span class="line">// 使用图片助手插入本地图片时, 图片复制到的路径</span><br><span class="line">"markdown-preview-enhanced.imageFolderPath": "./res/",</span><br><span class="line"></span><br><span class="line">//----------------- paset image -------------------</span><br><span class="line">"pasteImage.path": "$&#123;currentFileDir&#125;/res/",</span><br><span class="line">"pasteImage.prefix": "./",</span><br><span class="line">"pasteImage.defaultName": "Y-MM-DD-HH-mm-ss",</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="42-Hexo生成带有图片的blog"></a></p><h2 id="4-2-Hexo生成带有图片的blog"><a href="#4-2-Hexo生成带有图片的blog" class="headerlink" title="4.2. Hexo生成带有图片的blog"></a>4.2. Hexo生成带有图片的blog</h2><p>当待生成 blog 的 markdown 中有图片时, 直接使用 hexo 生成的 Html 是无法正常显示图片的. 因为相对于 html文件而言, 类似于 <code>./res/test.png</code> 的这些路径找不到了. Hexo 是以时间为目录来组织生成的 html 的, 这些 html 分散在很多个以日期标注的文件夹下, 一个个复制到对应文件夹下有点累. 所以笔者的解决方法是, 修改待发布的markdown 中 <code>./res/test.png</code> 为 <code>/res/test.png</code>, 这样只要将用到的图片复制到 hexo 的 <code>source/res/</code> 目录下, hexo 在生成时, 会自动把这些文件拷贝到 html 同级目录中. 这样就能正常显示了.</p><p>这个修改路径的工作可以直接交给脚本去执行. 顺便还能给文件加个公共的Head 和 Tail.</p><p>为了简化 “脚本中查找本文档用到的图片” 逻辑, 笔者在写文档时, 将所有的图片资源引用都放到了文章开头, 格式如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 放于前面</span><br><span class="line"><span class="comment">&lt;!-- RES --&gt;</span></span><br><span class="line">[img1]: /res/mdImg/imgTest.png</span><br><span class="line"><span class="comment">&lt;!-- /RES --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![图片名][img1]</span><br></pre></td></tr></table></figure><p><a id="toc_anchor" name="43-使用码云的webhooks"></a></p><h2 id="4-3-使用码云的webhooks"><a href="#4-3-使用码云的webhooks" class="headerlink" title="4.3. 使用码云的webhooks"></a>4.3. 使用码云的webhooks</h2><p>可以使用 node.js 快速搭建一个支持 码云 web hooks 请求的服务. 可以直接引用库 <code>gitee-webhook-handler</code>. 在自己的 js 中调用脚本执行即可.</p><p>如果使用的是其他的 git 仓库, 比如 GitHub, Coding 等, 可以直接引用对应的库来使用. </p><blockquote><p>如果本文有幸激发起你的一些思考, 欢迎通过评论的形式给与反馈, 与你与我都是一种成长.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识管理 </tag>
            
            <tag> 工具 </tag>
            
            <tag> Python </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
